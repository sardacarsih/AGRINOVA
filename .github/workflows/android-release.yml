name: Android Release

on:
  push:
    branches:
      - develop
      - main
    paths:
      - 'apps/mobile/**'
      - '.github/workflows/android-release.yml'
  workflow_dispatch:
    inputs:
      target_track:
        description: 'Manual run target track (non-production only)'
        type: choice
        required: true
        default: internal
        options:
          - internal
          - closed
      version_name:
        description: 'Optional Android versionName override'
        required: false
        default: ''
      version_code:
        description: 'Optional Android versionCode override'
        required: false
        default: ''
      source_commit:
        description: 'Commit SHA from develop artifact (required for closed promotion)'
        required: false
        default: ''

permissions:
  contents: read
  actions: read

concurrency:
  group: android-release-mobile
  cancel-in-progress: false

env:
  FLUTTER_VERSION: '3.38.9'
  JAVA_VERSION: '17'
  ANDROID_MAX_VERSION_CODE: '2100000000'

jobs:
  plan:
    name: Plan Release Track and Version
    runs-on: ubuntu-latest
    outputs:
      track: ${{ steps.plan.outputs.track }}
      play_track: ${{ steps.plan.outputs.play_track }}
      environment: ${{ steps.plan.outputs.environment }}
      is_production: ${{ steps.plan.outputs.is_production }}
      requires_build: ${{ steps.plan.outputs.requires_build }}
      source_commit: ${{ steps.plan.outputs.source_commit }}
      artifact_name: ${{ steps.plan.outputs.artifact_name }}
      version_name: ${{ steps.plan.outputs.version_name }}
      version_code: ${{ steps.plan.outputs.version_code }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Resolve track and version
        id: plan
        env:
          GITHUB_TOKEN: ${{ github.token }}
        shell: bash
        run: |
          set -euo pipefail

          event_name="${{ github.event_name }}"
          ref_type="${{ github.ref_type }}"
          ref_name="${{ github.ref_name }}"

          track=""
          play_track=""
          environment=""
          is_production="false"
          requires_build="true"
          source_commit="${GITHUB_SHA}"
          artifact_name=""
          version_name=""
          version_code=""

          resolve_closed_source_commit() {
            # Primary path: merge commit push to main (HEAD^2 points to develop SHA).
            if git rev-parse --verify HEAD^2 >/dev/null 2>&1; then
              git rev-parse HEAD^2
              return 0
            fi

            # Fallback: direct commit on main after merge; reuse latest merged develop SHA.
            merge_commit="$(git rev-list --merges -n 1 HEAD || true)"
            if [[ -n "$merge_commit" ]] && git rev-parse --verify "${merge_commit}^2" >/dev/null 2>&1; then
              git rev-parse "${merge_commit}^2"
              return 0
            fi

            return 1
          }

          resolve_latest_develop_run_commit() {
            # Last-resort fallback for repositories using squash/rebase merges to main.
            python - <<'PY'
          import json
          import os
          import sys
          import urllib.request

          repo = os.environ.get("GITHUB_REPOSITORY", "")
          token = os.environ.get("GITHUB_TOKEN", "")
          if not repo or not token:
            sys.exit(1)

          url = (
            f"https://api.github.com/repos/{repo}/actions/workflows/android-release.yml/runs"
            "?branch=develop&event=push&status=success&per_page=20"
          )
          req = urllib.request.Request(
            url,
            headers={
              "Authorization": f"Bearer {token}",
              "Accept": "application/vnd.github+json",
              "X-GitHub-Api-Version": "2022-11-28",
              "User-Agent": "agrinova-android-release-plan",
            },
          )

          try:
            with urllib.request.urlopen(req, timeout=20) as resp:
              data = json.load(resp)
          except Exception:
            sys.exit(1)

          runs = data.get("workflow_runs", [])
          if not runs:
            sys.exit(1)

          head_sha = runs[0].get("head_sha", "")
          if head_sha and len(head_sha) == 40:
            print(head_sha)
            sys.exit(0)

          sys.exit(1)
          PY
          }

          if [[ "$event_name" == "push" && "$ref_type" == "branch" ]]; then
            if [[ "$ref_name" == "develop" ]]; then
              track="internal"
              play_track="internal"
              environment="mobile-internal"
            elif [[ "$ref_name" == "main" ]]; then
              track="closed"
              play_track="alpha"
              environment="mobile-closed"
              requires_build="false"
              resolved_closed_source_commit="$(resolve_closed_source_commit || true)"
              if [[ -n "$resolved_closed_source_commit" ]]; then
                source_commit="$resolved_closed_source_commit"
              else
                resolved_latest_develop_commit="$(resolve_latest_develop_run_commit || true)"
                if [[ -n "$resolved_latest_develop_commit" ]]; then
                  source_commit="$resolved_latest_develop_commit"
                  echo "::warning::Using latest successful develop run commit as source_commit: $source_commit"
                else
                  echo "::error::Unable to resolve develop source commit for closed promotion on main. Use workflow_dispatch with source_commit."
                  exit 1
                fi
              fi
            else
              echo "::error::Unsupported branch '$ref_name'. Allowed: develop, main."
              exit 1
            fi
          elif [[ "$event_name" == "push" && "$ref_type" == "tag" ]]; then
            echo "::error::Tag-based production release is temporarily disabled. Use branch push (develop/main) or workflow_dispatch for internal/closed."
            exit 1
          elif [[ "$event_name" == "workflow_dispatch" ]]; then
            track="${{ github.event.inputs.target_track }}"
            environment="mobile-${track}"
            if [[ "$track" == "closed" ]]; then
              play_track="alpha"
              requires_build="false"
              manual_source_commit="${{ github.event.inputs.source_commit }}"
              if [[ -n "$manual_source_commit" ]]; then
                source_commit="$manual_source_commit"
              elif [[ "$ref_name" == "main" ]]; then
                resolved_closed_source_commit="$(resolve_closed_source_commit || true)"
                if [[ -n "$resolved_closed_source_commit" ]]; then
                  source_commit="$resolved_closed_source_commit"
                else
                  resolved_latest_develop_commit="$(resolve_latest_develop_run_commit || true)"
                  if [[ -n "$resolved_latest_develop_commit" ]]; then
                    source_commit="$resolved_latest_develop_commit"
                    echo "::warning::Using latest successful develop run commit as source_commit: $source_commit"
                  else
                    echo "::error::closed promotion requires source_commit input (develop commit SHA)."
                    exit 1
                  fi
                fi
              else
                echo "::error::closed promotion requires source_commit input (develop commit SHA)."
                exit 1
              fi
            elif [[ "$track" == "internal" ]]; then
              play_track="internal"
            else
              echo "::error::Unsupported workflow_dispatch track '$track'. Allowed: internal, closed."
              exit 1
            fi
          else
            echo "::error::Unsupported trigger '$event_name'."
            exit 1
          fi

          if [[ ! "$source_commit" =~ ^[0-9a-f]{40}$ ]]; then
            echo "::error::Invalid source_commit '$source_commit'. Expected full 40-char SHA."
            exit 1
          fi

          artifact_name="agrinova-android-aab-${source_commit}"

          pubspec_version_line="$(grep -E '^version:' apps/mobile/pubspec.yaml | head -n1 || true)"
          pubspec_version="$(echo "$pubspec_version_line" | awk '{print $2}')"
          base_version="${pubspec_version%%+*}"

          if [[ ! "$base_version" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "::error::Cannot parse base semantic version from apps/mobile/pubspec.yaml (found '$pubspec_version')."
            exit 1
          fi

          if [[ "$requires_build" == "true" ]]; then
            if [[ -z "$version_name" ]]; then
              manual_version_name="${{ github.event.inputs.version_name }}"
              if [[ "$event_name" == "workflow_dispatch" && -n "$manual_version_name" ]]; then
                version_name="$manual_version_name"
              elif [[ "$track" == "internal" ]]; then
                version_name="${base_version}-dev.${GITHUB_RUN_NUMBER}"
              elif [[ "$track" == "closed" ]]; then
                version_name="${base_version}-rc.${GITHUB_RUN_NUMBER}"
              else
                version_name="$base_version"
              fi
            fi

            manual_version_code="${{ github.event.inputs.version_code }}"
            if [[ -n "$manual_version_code" ]]; then
              version_code="$manual_version_code"
            else
              version_code="$(date +%s)"
            fi

            if [[ ! "$version_code" =~ ^[0-9]+$ ]]; then
              echo "::error::versionCode must be a positive integer (got '$version_code')."
              exit 1
            fi

            if (( version_code <= 0 )); then
              echo "::error::versionCode must be greater than zero."
              exit 1
            fi

            if (( version_code > ANDROID_MAX_VERSION_CODE )); then
              echo "::error::versionCode exceeds Android max (${ANDROID_MAX_VERSION_CODE})."
              exit 1
            fi

            if [[ "$is_production" == "true" && ! "$version_name" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "::error::Production versionName must be semantic (X.Y.Z)."
              exit 1
            fi
          else
            version_name="from-artifact"
            version_code="from-artifact"
          fi

          echo "track=$track" >> "$GITHUB_OUTPUT"
          echo "play_track=$play_track" >> "$GITHUB_OUTPUT"
          echo "environment=$environment" >> "$GITHUB_OUTPUT"
          echo "is_production=$is_production" >> "$GITHUB_OUTPUT"
          echo "requires_build=$requires_build" >> "$GITHUB_OUTPUT"
          echo "source_commit=$source_commit" >> "$GITHUB_OUTPUT"
          echo "artifact_name=$artifact_name" >> "$GITHUB_OUTPUT"
          echo "version_name=$version_name" >> "$GITHUB_OUTPUT"
          echo "version_code=$version_code" >> "$GITHUB_OUTPUT"

          echo "Release plan:"
          echo "  event       = $event_name"
          echo "  ref         = $ref_type/$ref_name"
          echo "  track       = $track"
          echo "  play_track  = $play_track"
          echo "  environment = $environment"
          echo "  production  = $is_production"
          echo "  build       = $requires_build"
          echo "  source      = $source_commit"
          echo "  artifact    = $artifact_name"
          echo "  versionName = $version_name"
          echo "  versionCode = $version_code"

  validate:
    name: Validate Flutter (analyze + test)
    runs-on: ubuntu-latest
    needs: plan
    timeout-minutes: 20
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Flutter ${{ env.FLUTTER_VERSION }}
        uses: subosito/flutter-action@v2
        with:
          flutter-version: ${{ env.FLUTTER_VERSION }}
          channel: stable
          cache: true

      - name: Install dependencies
        working-directory: apps/mobile
        run: flutter pub get

      - name: Analyze
        working-directory: apps/mobile
        run: flutter analyze

      - name: Run smoke tests
        working-directory: apps/mobile
        run: flutter test test/widget_test.dart

  build-and-deploy:
    name: Build and Deploy to Google Play
    if: needs.plan.outputs.requires_build == 'true'
    runs-on: ubuntu-latest
    needs: [plan, validate]
    timeout-minutes: 50
    environment:
      name: ${{ needs.plan.outputs.environment }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Java ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: ${{ env.JAVA_VERSION }}

      - name: Set up Flutter ${{ env.FLUTTER_VERSION }}
        uses: subosito/flutter-action@v2
        with:
          flutter-version: ${{ env.FLUTTER_VERSION }}
          channel: stable
          cache: true

      - name: Write google-services.json
        env:
          GOOGLE_SERVICES_JSON: ${{ secrets.GOOGLE_SERVICES_JSON_BASE64 }}
        working-directory: apps/mobile/android/app
        shell: bash
        run: |
          set -euo pipefail
          if [[ -n "$GOOGLE_SERVICES_JSON" ]]; then
            echo "$GOOGLE_SERVICES_JSON" | base64 --decode > google-services.json
            echo "google-services.json written from secret."
          fi
          if [[ ! -f google-services.json ]]; then
            echo "::error::google-services.json missing. Commit file or set GOOGLE_SERVICES_JSON_BASE64."
            exit 1
          fi

      - name: Write keystore and key.properties
        env:
          KEYSTORE_B64: ${{ secrets.ANDROID_KEYSTORE_BASE64 }}
          STORE_PASSWORD: ${{ secrets.ANDROID_KEYSTORE_PASSWORD }}
          KEY_PASSWORD: ${{ secrets.ANDROID_KEY_PASSWORD }}
          KEY_ALIAS: ${{ secrets.ANDROID_KEY_ALIAS }}
        working-directory: apps/mobile/android
        shell: bash
        run: |
          set -euo pipefail
          echo "$KEYSTORE_B64" | base64 --decode > app/release.keystore
          printf 'storePassword=%s\nkeyPassword=%s\nkeyAlias=%s\nstoreFile=%s\n' \
            "$STORE_PASSWORD" \
            "$KEY_PASSWORD" \
            "$KEY_ALIAS" \
            "release.keystore" \
            > key.properties

      - name: Verify versionCode is higher than Play Store
        env:
          GOOGLE_PLAY_SERVICE_ACCOUNT_JSON: ${{ secrets.GOOGLE_PLAY_SERVICE_ACCOUNT_JSON }}
          ANDROID_PACKAGE_NAME: ${{ secrets.ANDROID_PACKAGE_NAME }}
          VERSION_CODE: ${{ needs.plan.outputs.version_code }}
        shell: bash
        run: |
          set -euo pipefail
          python -m pip install --quiet --upgrade google-api-python-client google-auth
          python - <<'PY'
          import json
          import os
          import sys
          from google.oauth2 import service_account
          from googleapiclient.discovery import build
          from googleapiclient.errors import HttpError

          package_name = os.environ["ANDROID_PACKAGE_NAME"]
          version_code = int(os.environ["VERSION_CODE"])
          service_account_info = json.loads(os.environ["GOOGLE_PLAY_SERVICE_ACCOUNT_JSON"])
          scopes = ["https://www.googleapis.com/auth/androidpublisher"]
          creds = service_account.Credentials.from_service_account_info(service_account_info, scopes=scopes)
          service = build("androidpublisher", "v3", credentials=creds, cache_discovery=False)

          edit = service.edits().insert(packageName=package_name, body={}).execute()
          edit_id = edit["id"]
          max_code = 0
          tracks = ["internal", "alpha", "beta", "production"]

          try:
            for track in tracks:
              try:
                resp = service.edits().tracks().get(
                  packageName=package_name,
                  editId=edit_id,
                  track=track
                ).execute()
              except HttpError as err:
                status = getattr(err.resp, "status", None)
                if status == 404:
                  continue
                raise

              for release in resp.get("releases", []):
                for code in release.get("versionCodes", []):
                  max_code = max(max_code, int(code))
          finally:
            try:
              service.edits().delete(packageName=package_name, editId=edit_id).execute()
            except Exception:
              pass

          if max_code and version_code <= max_code:
            print(f"::error::versionCode {version_code} must be greater than current Play max {max_code}.")
            sys.exit(1)

          print(f"versionCode check passed: {version_code} > {max_code}")
          PY

      - name: Install Flutter dependencies
        working-directory: apps/mobile
        run: flutter pub get

      - name: Build release AAB
        working-directory: apps/mobile
        run: |
          flutter build appbundle \
            --release \
            --build-name=${{ needs.plan.outputs.version_name }} \
            --build-number=${{ needs.plan.outputs.version_code }} \
            --dart-define-from-file=env/prod.json

      - name: Prepare release notes
        id: notes
        shell: bash
        run: |
          set -euo pipefail
          WHATSNEW_DIR="$(mktemp -d)/whatsnew"
          mkdir -p "$WHATSNEW_DIR"

          STATIC_ID="apps/mobile/whatsnew/whatsnew-id-ID"
          STATIC_ID_LEGACY="apps/mobile/whatsnew/whatsnew-id"
          STATIC_EN="apps/mobile/whatsnew/whatsnew-en-US"

          if [[ -f "$STATIC_ID" ]]; then
            cp "$STATIC_ID" "$WHATSNEW_DIR/whatsnew-id-ID"
          elif [[ -f "$STATIC_ID_LEGACY" ]]; then
            cp "$STATIC_ID_LEGACY" "$WHATSNEW_DIR/whatsnew-id-ID"
          else
            TAG_BODY=""
            if [[ "${{ github.ref_type }}" == "tag" ]]; then
              TAG_BODY="$(git tag -l --format='%(contents:body)' "${{ github.ref_name }}" 2>/dev/null || true)"
              if [[ -z "$TAG_BODY" ]]; then
                TAG_BODY="$(git tag -l --format='%(contents:subject)' "${{ github.ref_name }}" 2>/dev/null || true)"
              fi
            fi

            if [[ -n "$TAG_BODY" ]]; then
              echo "$TAG_BODY" | head -c 500 > "$WHATSNEW_DIR/whatsnew-id-ID"
            else
              current_tag=""
              if [[ "${{ github.ref_type }}" == "tag" ]]; then
                current_tag="${{ github.ref_name }}"
              fi

              previous_tag=""
              while IFS= read -r tag; do
                [[ -z "$tag" ]] && continue
                if [[ -n "$current_tag" && "$tag" == "$current_tag" ]]; then
                  continue
                fi
                previous_tag="$tag"
                break
              done < <(git tag --list 'mobile/v*.*.*' --sort=-version:refname)

              COMMITS_FILE="$(mktemp)"
              if [[ -n "$previous_tag" ]]; then
                git log --no-merges --format='%s' "${previous_tag}..HEAD" > "$COMMITS_FILE" || true
              else
                git log --no-merges -n 30 --format='%s' > "$COMMITS_FILE" || true
              fi

              NOTES_TMP="$(mktemp)"
              {
                echo "Versi ${{ needs.plan.outputs.version_name }}:"
              } > "$NOTES_TMP"

              changes_count=0
              while IFS= read -r subject; do
                [[ -z "$subject" ]] && continue
                [[ "$subject" =~ ^Merge[[:space:]] ]] && continue

                commit_type="other"
                commit_desc="$subject"
                if [[ "$subject" == *:* ]]; then
                  prefix="${subject%%:*}"
                  rest="${subject#*:}"
                  commit_desc="${rest# }"

                  # Parse conventional commit prefix: type(scope)!:
                  commit_type="${prefix%%(*}"
                  commit_type="${commit_type%!}"
                  commit_type="${commit_type,,}"

                  if [[ -z "$commit_desc" ]]; then
                    commit_desc="$subject"
                  fi
                fi

                label="Perubahan"
                case "$commit_type" in
                  fix) label="Perbaikan" ;;
                  feat) label="Fitur" ;;
                  perf) label="Performa" ;;
                  refactor) label="Refactor" ;;
                  build|ci|chore) label="Build/CI" ;;
                  docs) label="Dokumentasi" ;;
                  test) label="Pengujian" ;;
                esac

                printf -- "- %s: %s\n" "$label" "$commit_desc" >> "$NOTES_TMP"
                changes_count=$((changes_count + 1))
                if (( changes_count >= 8 )); then
                  break
                fi
              done < "$COMMITS_FILE"

              if (( changes_count > 0 )); then
                head -c 500 "$NOTES_TMP" > "$WHATSNEW_DIR/whatsnew-id-ID"
              else
                echo "Perbaikan bug dan peningkatan performa track ${{ needs.plan.outputs.track }} untuk versi ${{ needs.plan.outputs.version_name }}." \
                  > "$WHATSNEW_DIR/whatsnew-id-ID"
              fi
            fi
          fi

          if [[ -f "$STATIC_EN" ]]; then
            cp "$STATIC_EN" "$WHATSNEW_DIR/whatsnew-en-US"
          else
            echo "Bug fixes and performance improvements for version ${{ needs.plan.outputs.version_name }}." \
              > "$WHATSNEW_DIR/whatsnew-en-US"
          fi

          echo "dir=$WHATSNEW_DIR" >> "$GITHUB_OUTPUT"

      - name: Package promotion artifact
        shell: bash
        run: |
          set -euo pipefail
          DIST_DIR="$RUNNER_TEMP/promotion"
          mkdir -p "$DIST_DIR/whatsnew"

          cp apps/mobile/build/app/outputs/bundle/release/app-release.aab "$DIST_DIR/app-release.aab"
          cp -R "${{ steps.notes.outputs.dir }}/." "$DIST_DIR/whatsnew/"

          if [[ -f apps/mobile/build/app/outputs/mapping/release/mapping.txt ]]; then
            cp apps/mobile/build/app/outputs/mapping/release/mapping.txt "$DIST_DIR/mapping.txt"
          fi

          AAB_SHA256="$(sha256sum "$DIST_DIR/app-release.aab" | awk '{print $1}')"
          cat > "$DIST_DIR/release-metadata.json" <<EOF
          {
            "source_commit": "${{ needs.plan.outputs.source_commit }}",
            "version_name": "${{ needs.plan.outputs.version_name }}",
            "version_code": "${{ needs.plan.outputs.version_code }}",
            "track": "${{ needs.plan.outputs.track }}",
            "play_track": "${{ needs.plan.outputs.play_track }}",
            "aab_sha256": "$AAB_SHA256",
            "build_run_id": "${{ github.run_id }}",
            "build_run_number": "${{ github.run_number }}"
          }
          EOF

      - name: Upload promotion artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ needs.plan.outputs.artifact_name }}
          path: ${{ runner.temp }}/promotion/**
          retention-days: 30

      - name: Deploy to Google Play
        uses: r0adkll/upload-google-play@v1
        with:
          serviceAccountJsonPlainText: ${{ secrets.GOOGLE_PLAY_SERVICE_ACCOUNT_JSON }}
          packageName: ${{ secrets.ANDROID_PACKAGE_NAME }}
          releaseFiles: apps/mobile/build/app/outputs/bundle/release/app-release.aab
          track: ${{ needs.plan.outputs.play_track }}
          status: completed
          mappingFile: apps/mobile/build/app/outputs/mapping/release/mapping.txt
          whatsNewDirectory: ${{ steps.notes.outputs.dir }}

      - name: Write job summary
        if: success()
        shell: bash
        run: |
          cat >> "$GITHUB_STEP_SUMMARY" << 'EOF'
          ## Android Release Deployed

          | Field | Value |
          |-------|-------|
          | **Version** | ${{ needs.plan.outputs.version_name }}+${{ needs.plan.outputs.version_code }} |
          | **Ref** | `${{ github.ref_name }}` |
          | **Track** | `${{ needs.plan.outputs.track }}` |
          | **Play Track** | `${{ needs.plan.outputs.play_track }}` |
          | **Environment** | `${{ needs.plan.outputs.environment }}` |
          | **Source Commit** | `${{ needs.plan.outputs.source_commit }}` |
          | **Promotion Artifact** | `${{ needs.plan.outputs.artifact_name }}` |
          | **Package** | `${{ secrets.ANDROID_PACKAGE_NAME }}` |
          | **Commit** | `${{ github.sha }}` |
          | **Run** | `#${{ github.run_number }}` |
          EOF

      - name: Clean up signing files
        if: always()
        run: |
          rm -f apps/mobile/android/app/release.keystore
          rm -f apps/mobile/android/key.properties
          rm -f apps/mobile/android/app/google-services.json

  promote-to-alpha:
    name: Promote Existing AAB to Alpha
    if: needs.plan.outputs.requires_build == 'false' && needs.plan.outputs.track == 'closed'
    runs-on: ubuntu-latest
    needs: [plan, validate]
    timeout-minutes: 30
    environment:
      name: ${{ needs.plan.outputs.environment }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Find develop run artifact for source commit
        id: find_artifact
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const sourceCommit = '${{ needs.plan.outputs.source_commit }}';
            const artifactName = '${{ needs.plan.outputs.artifact_name }}';
            const workflowPath = '.github/workflows/android-release.yml';

            const runs = await github.paginate(
              github.rest.actions.listWorkflowRunsForRepo,
              {
                owner,
                repo,
                branch: 'develop',
                event: 'push',
                status: 'success',
                per_page: 100
              }
            );

            const candidates = runs
              .filter((run) => run.head_sha === sourceCommit)
              .filter((run) => typeof run.path === 'string' && run.path.startsWith(workflowPath))
              .sort((a, b) => b.id - a.id);

            if (candidates.length === 0) {
              core.setFailed(`No successful develop workflow run found for source commit ${sourceCommit}.`);
              return;
            }

            for (const run of candidates) {
              const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
                owner,
                repo,
                run_id: run.id,
                per_page: 100
              });

              const match = artifacts.data.artifacts.find(
                (artifact) => artifact.name === artifactName && !artifact.expired
              );

              if (match) {
                core.info(`Using run ${run.id} for commit ${sourceCommit}.`);
                core.setOutput('run_id', String(run.id));
                core.setOutput('artifact_id', String(match.id));
                return;
              }
            }

            core.setFailed(
              `Artifact ${artifactName} not found in successful develop runs for commit ${sourceCommit}.`
            );

      - name: Download promotion artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.plan.outputs.artifact_name }}
          run-id: ${{ steps.find_artifact.outputs.run_id }}
          github-token: ${{ github.token }}
          path: ${{ runner.temp }}/promotion

      - name: Validate artifact metadata
        id: metadata
        shell: bash
        run: |
          set -euo pipefail

          ART_DIR="${{ runner.temp }}/promotion"
          META_FILE="$(find "$ART_DIR" -type f -name 'release-metadata.json' | head -n1 || true)"
          AAB_FILE="$(find "$ART_DIR" -type f -name 'app-release.aab' | head -n1 || true)"
          NOTES_DIR="$(find "$ART_DIR" -type d -name 'whatsnew' | head -n1 || true)"

          [[ -n "$META_FILE" && -f "$META_FILE" ]] || { echo "::error::Missing release-metadata.json in artifact."; exit 1; }
          [[ -n "$AAB_FILE" && -f "$AAB_FILE" ]] || { echo "::error::Missing app-release.aab in artifact."; exit 1; }

          python - "$META_FILE" "$AAB_FILE" <<'PY' > "$RUNNER_TEMP/meta.env"
          import hashlib
          import json
          import sys
          from pathlib import Path

          meta = json.loads(Path(sys.argv[1]).read_text(encoding="utf-8"))
          aab_path = Path(sys.argv[2])
          aab_sha256 = hashlib.sha256(aab_path.read_bytes()).hexdigest()
          expected_sha256 = meta.get("aab_sha256", "")
          if expected_sha256 and expected_sha256 != aab_sha256:
            print("error=sha256-mismatch")
            sys.exit(2)

          required = ["source_commit", "version_name", "version_code"]
          for key in required:
            if not meta.get(key):
              print(f"error=missing-{key}")
              sys.exit(3)

          print(f"meta_source_commit={meta['source_commit']}")
          print(f"meta_version_name={meta['version_name']}")
          print(f"meta_version_code={meta['version_code']}")
          print(f"meta_aab_sha256={aab_sha256}")
          PY

          source "$RUNNER_TEMP/meta.env"
          if [[ "${meta_source_commit}" != "${{ needs.plan.outputs.source_commit }}" ]]; then
            echo "::error::Artifact source_commit ${meta_source_commit} does not match expected ${{ needs.plan.outputs.source_commit }}."
            exit 1
          fi

          echo "version_name=${meta_version_name}" >> "$GITHUB_OUTPUT"
          echo "version_code=${meta_version_code}" >> "$GITHUB_OUTPUT"
          echo "aab_sha256=${meta_aab_sha256}" >> "$GITHUB_OUTPUT"
          echo "aab_file=${AAB_FILE}" >> "$GITHUB_OUTPUT"
          if [[ -n "$NOTES_DIR" ]]; then
            echo "notes_dir=${NOTES_DIR}" >> "$GITHUB_OUTPUT"
          fi

      - name: Ensure release notes exists
        id: notes
        shell: bash
        run: |
          set -euo pipefail
          NOTES_DIR="${{ steps.metadata.outputs.notes_dir }}"
          if [[ -z "$NOTES_DIR" ]]; then
            NOTES_DIR="${{ runner.temp }}/promotion/whatsnew"
          fi
          mkdir -p "$NOTES_DIR"

          if [[ ! -f "$NOTES_DIR/whatsnew-id-ID" ]]; then
            echo "Perbaikan bug dan peningkatan performa untuk versi ${{ steps.metadata.outputs.version_name }}." > "$NOTES_DIR/whatsnew-id-ID"
          fi

          if [[ ! -f "$NOTES_DIR/whatsnew-en-US" ]]; then
            echo "Bug fixes and performance improvements for version ${{ steps.metadata.outputs.version_name }}." > "$NOTES_DIR/whatsnew-en-US"
          fi

          echo "dir=${NOTES_DIR}" >> "$GITHUB_OUTPUT"

      - name: Promote existing versionCode to alpha
        env:
          GOOGLE_PLAY_SERVICE_ACCOUNT_JSON: ${{ secrets.GOOGLE_PLAY_SERVICE_ACCOUNT_JSON }}
          ANDROID_PACKAGE_NAME: ${{ secrets.ANDROID_PACKAGE_NAME }}
          VERSION_CODE: ${{ steps.metadata.outputs.version_code }}
          VERSION_NAME: ${{ steps.metadata.outputs.version_name }}
          NOTES_DIR: ${{ steps.notes.outputs.dir }}
        shell: bash
        run: |
          set -euo pipefail
          python -m pip install --quiet --upgrade google-api-python-client google-auth
          python - <<'PY'
          import json
          import os
          import sys
          from pathlib import Path

          from google.oauth2 import service_account
          from googleapiclient.discovery import build
          from googleapiclient.errors import HttpError

          def read_text(path: Path) -> str:
            if not path.exists():
              return ""
            return path.read_text(encoding="utf-8").strip()

          package_name = os.environ["ANDROID_PACKAGE_NAME"]
          version_code = str(int(os.environ["VERSION_CODE"]))
          version_name = os.environ["VERSION_NAME"]
          notes_dir = Path(os.environ["NOTES_DIR"])

          release_notes = []
          note_id = read_text(notes_dir / "whatsnew-id-ID")
          note_en = read_text(notes_dir / "whatsnew-en-US")
          if note_id:
            release_notes.append({"language": "id-ID", "text": note_id[:500]})
          if note_en:
            release_notes.append({"language": "en-US", "text": note_en[:500]})

          service_account_info = json.loads(os.environ["GOOGLE_PLAY_SERVICE_ACCOUNT_JSON"])
          scopes = ["https://www.googleapis.com/auth/androidpublisher"]
          creds = service_account.Credentials.from_service_account_info(service_account_info, scopes=scopes)
          service = build("androidpublisher", "v3", credentials=creds, cache_discovery=False)

          edit = service.edits().insert(packageName=package_name, body={}).execute()
          edit_id = edit["id"]

          def collect_codes(track_response: dict) -> set[str]:
            codes = set()
            for release in track_response.get("releases", []):
              for code in release.get("versionCodes", []):
                codes.add(str(code))
            return codes

          try:
            try:
              internal = service.edits().tracks().get(
                packageName=package_name,
                editId=edit_id,
                track="internal",
              ).execute()
            except HttpError as err:
              if getattr(err.resp, "status", None) == 404:
                print("::error::Internal track not found in Play Console for this app.")
                sys.exit(1)
              raise

            internal_codes = collect_codes(internal)
            if version_code not in internal_codes:
              print(
                f"::error::versionCode {version_code} is not present in internal track. "
                "Run develop build/deploy first."
              )
              sys.exit(1)

            alpha_codes = set()
            try:
              alpha = service.edits().tracks().get(
                packageName=package_name,
                editId=edit_id,
                track="alpha",
              ).execute()
              alpha_codes = collect_codes(alpha)
            except HttpError as err:
              if getattr(err.resp, "status", None) != 404:
                raise

            if version_code in alpha_codes:
              print(f"versionCode {version_code} already exists in alpha track. No promotion needed.")
            else:
              release = {
                "name": version_name,
                "status": "completed",
                "versionCodes": [version_code],
              }
              if release_notes:
                release["releaseNotes"] = release_notes

              service.edits().tracks().update(
                packageName=package_name,
                editId=edit_id,
                track="alpha",
                body={"releases": [release]},
              ).execute()
              print(f"Promoted versionCode {version_code} from internal to alpha.")

            service.edits().commit(packageName=package_name, editId=edit_id).execute()
          except Exception:
            try:
              service.edits().delete(packageName=package_name, editId=edit_id).execute()
            except Exception:
              pass
            raise
          PY

      - name: Write job summary
        if: success()
        shell: bash
        run: |
          cat >> "$GITHUB_STEP_SUMMARY" << 'EOF'
          ## Android Promotion Deployed

          | Field | Value |
          |-------|-------|
          | **Version** | ${{ steps.metadata.outputs.version_name }}+${{ steps.metadata.outputs.version_code }} |
          | **Ref** | `${{ github.ref_name }}` |
          | **Track** | `${{ needs.plan.outputs.track }}` |
          | **Play Track** | `${{ needs.plan.outputs.play_track }}` |
          | **Environment** | `${{ needs.plan.outputs.environment }}` |
          | **Source Commit** | `${{ needs.plan.outputs.source_commit }}` |
          | **AAB SHA256** | `${{ steps.metadata.outputs.aab_sha256 }}` |
          | **Promotion Artifact** | `${{ needs.plan.outputs.artifact_name }}` |
          | **Artifact Run ID** | `${{ steps.find_artifact.outputs.run_id }}` |
          | **Package** | `${{ secrets.ANDROID_PACKAGE_NAME }}` |
          | **Commit** | `${{ github.sha }}` |
          | **Run** | `#${{ github.run_number }}` |
          EOF

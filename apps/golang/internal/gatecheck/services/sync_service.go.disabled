package services

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/google/uuid"
	"gorm.io/gorm"

	"agrinovagraphql/server/internal/gatecheck/models"
	"agrinovagraphql/server/internal/gatecheck/repositories"
	"agrinovagraphql/server/internal/graphql/generated"
	"agrinovagraphql/server/internal/middleware"
)

// =============================================================================
// Service Interfaces
// =============================================================================

// SyncService defines the interface for sync operations
type SyncService interface {
	// Main sync operations
	SyncGateCheckRecords(ctx context.Context, input generated.GateCheckSyncInput) (*generated.SyncResult, error)
	SyncQRTokens(ctx context.Context, input generated.QRTokenSyncInput) (*generated.SyncResult, error)
	SyncPhotos(ctx context.Context, input generated.PhotoSyncInput) (*generated.PhotoSyncResult, error)
	BatchSync(ctx context.Context, input generated.BatchSyncInput) (*generated.BatchSyncResult, error)

	SyncEmployeeLogs(ctx context.Context, input generated.EmployeeLogSyncInput) (*generated.SyncResult, error)
	SyncGuestLog(ctx context.Context, input generated.GuestLogSyncIndividualInput) (*generated.GuestLogSyncResult, error)

	// Query operations
	GetSyncRecords(ctx context.Context, input generated.GateCheckSyncQuery) (*generated.GateCheckSyncResponse, error)
	GetPendingSyncItems(ctx context.Context, deviceID string, batchSize int) (*generated.SyncBatchResponse, error)
}

// =============================================================================
// Service Implementation
// =============================================================================

// syncService implements SyncService interface
type syncService struct {
	db       *gorm.DB
	repo     repositories.SyncRepository
	userRepo UserRepository
}

// UserRepository interface for user operations (dependency)
type UserRepository interface {
	GetUserByID(ctx context.Context, id string) (*generated.User, error)
}

// NewSyncService creates a new sync service
func NewSyncService(db *gorm.DB) SyncService {
	return &syncService{
		db:   db,
		repo: repositories.NewSyncRepository(db),
	}
}

// NewSyncServiceWithDependencies creates a sync service with injected dependencies
func NewSyncServiceWithDependencies(db *gorm.DB, repo repositories.SyncRepository, userRepo UserRepository) SyncService {
	return &syncService{
		db:       db,
		repo:     repo,
		userRepo: userRepo,
	}
}

// =============================================================================
// SyncGateCheckRecords - Main sync endpoint for guest logs
// =============================================================================

func (s *syncService) SyncGateCheckRecords(ctx context.Context, input generated.GateCheckSyncInput) (*generated.SyncResult, error) {
	startTime := time.Now()
	transactionID := uuid.New().String()

	// Create sync transaction record
	syncTx := &models.SyncTransaction{
		ID:       transactionID,
		DeviceID: input.DeviceID,
		Status:   models.SyncResultStatus(models.SyncPending),
	}
	if err := s.repo.CreateSyncTransaction(ctx, syncTx); err != nil {
		return s.errorResult(transactionID, "Failed to create sync transaction", err)
	}

	var (
		recordsProcessed  int
		conflictsDetected int
		errors            []string
	)

	// Process each guest log record
	for _, record := range input.Records {
		result := s.processGuestLogSync(ctx, record, input.DeviceID, input.ConflictResolution)

		if result.success {
			recordsProcessed++
		} else {
			errors = append(errors, fmt.Sprintf("Record %s: %s", record.LocalID, result.error))
		}

		if result.conflict {
			conflictsDetected++
		}
	}

	// Complete transaction
	status := models.ResultSuccess
	if len(errors) > 0 {
		status = models.ResultFailed
	}
	s.repo.CompleteSyncTransaction(ctx, transactionID, status)

	return &generated.SyncResult{
		Success:           len(errors) == 0,
		RecordsProcessed:  int32(recordsProcessed),
		ConflictsDetected: int32(conflictsDetected),
		TransactionID:     transactionID,
		Message:           fmt.Sprintf("Processed %d records in %v", recordsProcessed, time.Since(startTime)),
		Errors:            errors,
		SyncedAt:          time.Now(),
	}, nil
}

// processGuestLogResult holds the result of processing a single guest log
type processGuestLogResult struct {
	success  bool
	conflict bool
	error    string
}

// processGuestLogSync processes a single guest log sync record
func (s *syncService) processGuestLogSync(ctx context.Context, record *generated.GuestLogSyncInput, deviceID string, resolution *generated.ConflictResolution) processGuestLogResult {
	result := processGuestLogResult{}

	// Check if record already exists (by local ID or server ID)
	existing, err := s.repo.GetGuestLogByLocalID(ctx, record.LocalID)

	if err != nil && err != gorm.ErrRecordNotFound {
		result.error = fmt.Sprintf("database error: %v", err)
		return result
	}

	if existing != nil {
		// Handle potential conflict
		if s.hasConflict(existing, record) {
			result.conflict = true

			// Apply conflict resolution
			resolvedData := s.resolveConflict(existing, record, resolution)
			if resolvedData != nil {
				if err := s.repo.UpdateGuestLog(ctx, existing.ID, resolvedData); err != nil {
					result.error = fmt.Sprintf("update failed: %v", err)
					return result
				}
			}
		} else {
			// Simple update
			updates := s.buildGuestLogUpdates(record)
			if err := s.repo.UpdateGuestLog(ctx, existing.ID, updates); err != nil {
				result.error = fmt.Sprintf("update failed: %v", err)
				return result
			}
		}
	} else {
		// Create new record
		guestLog := s.buildGuestLogFromInput(ctx, record, deviceID)
		if err := s.repo.CreateGuestLog(ctx, guestLog); err != nil {
			result.error = fmt.Sprintf("create failed: %v", err)
			return result
		}
	}

	result.success = true
	return result
}

// hasConflict checks if there's a conflict between server and client data
func (s *syncService) hasConflict(server *models.GuestLog, client *generated.GuestLogSyncInput) bool {
	// Compare versions if available
	if client.LocalVersion > 0 {
		// If client version is older than server, it's a conflict
		return server.UpdatedAt.After(client.LastUpdated)
	}
	return false
}

// resolveConflict applies conflict resolution strategy
func (s *syncService) resolveConflict(server *models.GuestLog, client *generated.GuestLogSyncInput, resolution *generated.ConflictResolution) map[string]interface{} {
	strategy := generated.ConflictResolutionLatestWins
	if resolution != nil {
		strategy = *resolution
	}

	switch strategy {
	case generated.ConflictResolutionLocalWins:
		return s.buildGuestLogUpdates(client)
	case generated.ConflictResolutionRemoteWins:
		return nil // Keep server version
	case generated.ConflictResolutionMerge:
		return s.mergeGuestLogData(server, client)
	case generated.ConflictResolutionLatestWins:
		if client.LastUpdated.After(server.UpdatedAt) {
			return s.buildGuestLogUpdates(client)
		}
		return nil
	default:
		return nil
	}
}

// mergeGuestLogData merges server and client data
func (s *syncService) mergeGuestLogData(server *models.GuestLog, client *generated.GuestLogSyncInput) map[string]interface{} {
	updates := make(map[string]interface{})

	// Take non-null values from client, keep server values for nulls
	if client.GuestName != "" {
		updates["guest_name"] = client.GuestName
	}
	if client.GuestCompany != nil && *client.GuestCompany != "" {
		updates["guest_company"] = *client.GuestCompany
	}
	if client.VehiclePlate != "" {
		updates["vehicle_plate"] = client.VehiclePlate
	}
	if client.Notes != nil {
		updates["notes"] = *client.Notes
	}

	// Always use latest exit time if available
	if client.ExitTime != nil && (server.ExitTime == nil || client.ExitTime.After(*server.ExitTime)) {
		updates["exit_time"] = client.ExitTime
	}

	updates["sync_status"] = models.SyncCompleted

	return updates
}

// buildGuestLogUpdates builds update map from client input
func (s *syncService) buildGuestLogUpdates(record *generated.GuestLogSyncInput) map[string]interface{} {
	updates := map[string]interface{}{
		"guest_name":    record.GuestName,
		"guest_purpose": record.GuestPurpose,
		"driver_name":   record.DriverName,
		"vehicle_plate": record.VehiclePlate,
		"vehicle_type":  record.VehicleType,
		"purpose":       record.Purpose,
		"gate_position": record.GatePosition,
		"status":        record.Status,
		"sync_status":   models.SyncCompleted,
	}

	if record.GuestCompany != nil {
		updates["guest_company"] = *record.GuestCompany
	}
	if record.GuestPhone != nil {
		updates["guest_phone"] = *record.GuestPhone
	}
	if record.Destination != nil {
		updates["destination"] = *record.Destination
	}
	if record.EntryTime != nil {
		updates["entry_time"] = *record.EntryTime
	}
	if record.ExitTime != nil {
		updates["exit_time"] = *record.ExitTime
	}
	if record.Notes != nil {
		updates["notes"] = *record.Notes
	}

	return updates
}

// buildGuestLogFromInput creates a new GuestLog from sync input
func (s *syncService) buildGuestLogFromInput(ctx context.Context, record *generated.GuestLogSyncInput, deviceID string) *models.GuestLog {
	userID := middleware.GetUserFromContext(ctx)
	companyID := record.CompanyID

	guestLog := &models.GuestLog{
		GuestID:          record.LocalID,
		GuestName:        record.GuestName,
		GuestPurpose:     record.GuestPurpose,
		DriverName:       record.DriverName,
		VehiclePlate:     record.VehiclePlate,
		VehicleType:      models.VehicleType(record.VehicleType),
		Purpose:          record.Purpose,
		GatePosition:     record.GatePosition,
		Status:           models.GuestLogStatus(record.Status),
		DeviceID:         deviceID,
		SyncStatus:       models.SyncCompleted,
		CreatedUserID:    userID,
		AuthorizedUserID: userID, // Assuming creator is authorizer for sync
		CompanyID:        companyID,
	}

	if record.GuestCompany != nil {
		guestLog.GuestCompany = record.GuestCompany
	}
	if record.GuestPhone != nil {
		guestLog.GuestPhone = record.GuestPhone
	}
	if record.Destination != nil {
		guestLog.Destination = record.Destination
	}
	if record.EntryTime != nil {
		guestLog.EntryTime = record.EntryTime
	}
	if record.ExitTime != nil {
		guestLog.ExitTime = record.ExitTime
	}
	if record.Notes != nil {
		guestLog.Notes = record.Notes
	}

	return guestLog
}

// =============================================================================
// SyncQRTokens - Sync QR tokens from mobile
// =============================================================================

func (s *syncService) SyncQRTokens(ctx context.Context, input generated.QRTokenSyncInput) (*generated.SyncResult, error) {
	transactionID := uuid.New().String()

	var (
		recordsProcessed  int
		conflictsDetected int
		errors            []string
	)

	for _, tokenRecord := range input.Tokens {
		// Check existing by JTI
		existing, err := s.repo.GetQRTokenByJTI(ctx, tokenRecord.Jti)

		if err != nil && err != gorm.ErrRecordNotFound {
			errors = append(errors, fmt.Sprintf("Token %s: database error", tokenRecord.LocalID))
			continue
		}

		if existing != nil {
			// Update existing token
			updates := map[string]interface{}{
				"current_usage": tokenRecord.CurrentUsage,
				"status":        tokenRecord.Status,
				"sync_status":   models.SyncCompleted,
			}
			if err := s.repo.UpdateQRToken(ctx, existing.ID, updates); err != nil {
				errors = append(errors, fmt.Sprintf("Token %s: update failed", tokenRecord.LocalID))
				continue
			}
		} else {
			// Create new token record
			token := &models.QRToken{
				JTI:              tokenRecord.Jti,
				GenerationIntent: models.GateIntent(tokenRecord.GenerationIntent),
				AllowedScan:      s.getOppositeIntent(models.GateIntent(tokenRecord.GenerationIntent)),
				CurrentUsage:     int(tokenRecord.CurrentUsage),
				Status:           models.QRTokenStatus(tokenRecord.Status),
				SyncStatus:       models.SyncCompleted,
			}

			if tokenRecord.GuestLogID != nil {
				token.GuestLogID = tokenRecord.GuestLogID
			}

			if err := s.repo.CreateQRToken(ctx, token); err != nil {
				errors = append(errors, fmt.Sprintf("Token %s: create failed", tokenRecord.LocalID))
				continue
			}
		}

		recordsProcessed++
	}

	return &generated.SyncResult{
		Success:           len(errors) == 0,
		RecordsProcessed:  int32(recordsProcessed),
		ConflictsDetected: int32(conflictsDetected),
		TransactionID:     transactionID,
		Message:           fmt.Sprintf("Processed %d QR tokens", recordsProcessed),
		Errors:            errors,
		SyncedAt:          time.Now(),
	}, nil
}

// getOppositeIntent returns the opposite gate intent
func (s *syncService) getOppositeIntent(intent models.GateIntent) models.GateIntent {
	if intent == models.GateEntry {
		return models.GateExit
	}
	return models.GateEntry
}

// =============================================================================
// SyncEmployeeLogs - Sync employee access logs from mobile
// =============================================================================

// =============================================================================
// SyncEmployeeLogs - Sync employee access logs from mobile
// =============================================================================

func (s *syncService) SyncEmployeeLogs(ctx context.Context, input generated.EmployeeLogSyncInput) (*generated.SyncResult, error) {
	transactionID := uuid.New().String()

	var (
		recordsProcessed  int
		conflictsDetected int
		errors            []string
	)

	for _, record := range input.Records {
		// Check existing by local ID
		existing, err := s.repo.GetEmployeeLogByLocalID(ctx, record.LocalID)

		if err != nil && err != gorm.ErrRecordNotFound {
			errors = append(errors, fmt.Sprintf("Employee log %s: database error", record.LocalID))
			continue
		}

		if existing != nil {
			// Check for conflict
			localVersion := 0
			if record.LocalVersion != nil {
				localVersion = int(*record.LocalVersion)
			}

			if existing.LocalVersion > localVersion {
				conflictsDetected++
				// Default strategy: LATEST_WINS based on timestamp if needed, or SERVER_WINS
				// For now, if server version is higher, we skip unless we have better conflict resolution logic
				// But we'll just log/count it and proceed to simple update if we want to force adherence
				// or skip. Let's assume we proceed with update if we want CLIENT_WINS behavior,
				// or skip if SERVER_WINS.
				// The input doesn't explicitly pass ConflictResolution enum here (it was in the old struct).
				// We'll perform update anyway for now as per "simple update" logic below.
			}

			// Update existing
			updates := s.buildEmployeeLogUpdates(record)
			if err := s.repo.UpdateEmployeeLog(ctx, existing.ID, updates); err != nil {
				errors = append(errors, fmt.Sprintf("Employee log %s: update failed", record.LocalID))
				continue
			}
		} else {
			// Create new record
			employeeLog := s.buildEmployeeLogFromRecord(record, input.DeviceID)
			if err := s.repo.CreateEmployeeLog(ctx, employeeLog); err != nil {
				errors = append(errors, fmt.Sprintf("Employee log %s: create failed", record.LocalID))
				continue
			}
		}

		recordsProcessed++
	}

	return &generated.SyncResult{
		Success:           len(errors) == 0,
		RecordsProcessed:  int32(recordsProcessed),
		ConflictsDetected: int32(conflictsDetected),
		TransactionID:     transactionID,
		Message:           fmt.Sprintf("Processed %d employee logs", recordsProcessed),
		Errors:            errors,
		SyncedAt:          time.Now(),
	}, nil
}

// buildEmployeeLogUpdates builds update map from sync record
func (s *syncService) buildEmployeeLogUpdates(record *generated.EmployeeLogSyncRecord) map[string]interface{} {
	updates := map[string]interface{}{
		"nama":          record.EmployeeName,
		"departement":   record.Department,
		"action":        record.Action,
		"gate_position": record.GatePosition,
		"scanned_at":    record.ScannedAt,
		"sync_status":   models.SyncCompleted,
	}

	if record.LocalVersion != nil {
		updates["local_version"] = *record.LocalVersion
	}
	if record.Notes != nil {
		updates["notes"] = *record.Notes
	}
	// Add other optional fields if present in input schema and model

	return updates
}

// buildEmployeeLogFromRecord creates an EmployeeLog from sync record
func (s *syncService) buildEmployeeLogFromRecord(record *generated.EmployeeLogSyncRecord, deviceID string) *models.EmployeeLog {
	log := &models.EmployeeLog{
		LogID:        record.LocalID,
		IDData:       record.Iddata,
		CompanyID:    record.CompanyID,
		NIK:          record.Nik, // Or record.EmployeeId if they are same/redundant
		Nama:         record.EmployeeName,
		Departement:  record.Department,
		Action:       models.EmployeeLogAction(record.Action),
		GatePosition: record.GatePosition,
		ScannedAt:    record.ScannedAt,
		QRTimestamp:  record.Timestamp.UnixMilli(),
		DeviceID:     deviceID,
		SyncStatus:   models.SyncCompleted,
	}

	if record.LocalVersion != nil {
		log.LocalVersion = int(*record.LocalVersion)
	}

	if record.Notes != nil {
		log.Notes = record.Notes
	}
	// Map other fields...

	return log
}

// =============================================================================
// SyncPhotos - Batch photo sync
// =============================================================================

func (s *syncService) SyncPhotos(ctx context.Context, input generated.PhotoSyncInput) (*generated.PhotoSyncResult, error) {
	var (
		photosProcessed   int
		successfulUploads int
		failedUploads     int
		totalBytes        int
		uploadErrors      []*generated.PhotoUploadError
	)

	for _, photoRecord := range input.Photos {
		photosProcessed++

		// Create photo record
		photo := &models.GateCheckPhoto{
			PhotoID:           photoRecord.PhotoID,
			RelatedRecordType: models.RecordType(photoRecord.RelatedRecordType),
			RelatedRecordID:   photoRecord.RelatedRecordID,
			LocalPath:         photoRecord.LocalPath,
			FileName:          photoRecord.FileName,
			FileSize:          int64(photoRecord.FileSize),
			FileHash:          photoRecord.FileHash,
			PhotoType:         models.PhotoType(photoRecord.PhotoType),
			TakenAt:           photoRecord.TakenAt,
			DeviceID:          input.DeviceID,
			SyncStatus:        models.SyncCompleted,
		}

		if err := s.repo.CreatePhoto(ctx, photo); err != nil {
			failedUploads++
			uploadErrors = append(uploadErrors, &generated.PhotoUploadError{
				LocalID: photoRecord.LocalID,
				Message: err.Error(),
				Code:    "UPLOAD_FAILED",
			})
			continue
		}

		successfulUploads++
		totalBytes += int(photoRecord.FileSize)
	}

	return &generated.PhotoSyncResult{
		PhotosProcessed:    int32(photosProcessed),
		SuccessfulUploads:  int32(successfulUploads),
		FailedUploads:      int32(failedUploads),
		Errors:             uploadErrors,
		TotalBytesUploaded: int32(totalBytes),
		SyncedAt:           time.Now(),
	}, nil
}

// =============================================================================
// BatchSync - Multi-entity batch sync
// =============================================================================

func (s *syncService) BatchSync(ctx context.Context, input generated.BatchSyncInput) (*generated.BatchSyncResult, error) {
	startTime := time.Now()
	transactionID := input.BatchID
	if transactionID == "" {
		transactionID = uuid.New().String()
	}

	var (
		operationsProcessed  int
		successfulOperations int
		failedOperations     int
		conflictsDetected    int
		batchErrors          []*generated.BatchSyncError
	)

	// Process within transaction
	err := s.repo.WithTransaction(ctx, func(repo repositories.SyncRepository) error {
		for i, op := range input.Operations {
			operationsProcessed++

			result := s.processBatchOperation(ctx, repo, op, input.DeviceID, input.ConflictResolution)

			if result.success {
				successfulOperations++
			} else {
				failedOperations++
				batchErrors = append(batchErrors, &generated.BatchSyncError{
					OperationIndex: int32(i),
					LocalID:        op.LocalID,
					Message:        result.error,
					ErrorType:      result.errorType,
				})
			}

			if result.conflict {
				conflictsDetected++
			}
		}
		return nil
	})

	if err != nil {
		return nil, fmt.Errorf("batch sync transaction failed: %w", err)
	}

	processingTime := time.Since(startTime).Milliseconds()

	return &generated.BatchSyncResult{
		TransactionID:        transactionID,
		OperationsProcessed:  int32(operationsProcessed),
		SuccessfulOperations: int32(successfulOperations),
		FailedOperations:     int32(failedOperations),
		ConflictsDetected:    int32(conflictsDetected),
		Errors:               batchErrors,
		ProcessingDurationMs: int32(processingTime),
		SyncedAt:             time.Now(),
	}, nil
}

// batchOperationResult holds the result of a batch operation
type batchOperationResult struct {
	success   bool
	conflict  bool
	error     string
	errorType string
}

// processBatchOperation processes a single batch operation
func (s *syncService) processBatchOperation(ctx context.Context, repo repositories.SyncRepository, op *generated.BatchSyncOperation, deviceID string, resolution *generated.ConflictResolution) batchOperationResult {
	result := batchOperationResult{}

	switch op.RecordType {
	case "GUEST_LOG":
		var guestLogInput generated.GuestLogSyncInput
		if err := json.Unmarshal([]byte(op.RecordData), &guestLogInput); err != nil {
			result.error = "invalid record data format"
			result.errorType = "PARSE_ERROR"
			return result
		}

		syncResult := s.processGuestLogSync(ctx, &guestLogInput, deviceID, resolution)
		result.success = syncResult.success
		result.conflict = syncResult.conflict
		result.error = syncResult.error
		if !result.success {
			result.errorType = "SYNC_ERROR"
		}

	case "QR_TOKEN":
		var tokenData map[string]interface{}
		if err := json.Unmarshal([]byte(op.RecordData), &tokenData); err != nil {
			result.error = "invalid token data format"
			result.errorType = "PARSE_ERROR"
			return result
		}
		// Process QR token...
		result.success = true

	default:
		result.error = fmt.Sprintf("unknown record type: %s", op.RecordType)
		result.errorType = "UNKNOWN_TYPE"
	}

	return result
}

// =============================================================================
// Query Operations
// =============================================================================

func (s *syncService) GetSyncRecords(ctx context.Context, input generated.GateCheckSyncQuery) (*generated.GateCheckSyncResponse, error) {
	limit := 100
	if input.Limit != nil {
		limit = int(*input.Limit)
	}

	logs, err := s.repo.GetPendingSyncGuestLogs(ctx, input.DeviceID, limit)
	if err != nil {
		return nil, fmt.Errorf("failed to get sync records: %w", err)
	}

	// Convert to generated types
	guestLogs := make([]*generated.GuestLog, len(logs))
	for i, log := range logs {
		guestLogs[i] = log.ToGenerated()
	}

	return &generated.GateCheckSyncResponse{
		Records:    guestLogs,
		TotalCount: int32(len(guestLogs)),
		HasMore:    len(guestLogs) == limit,
		SyncMetadata: &generated.SyncMetadata{
			LastSyncAt:       time.Now(),
			ServerTimestamp:  time.Now(),
			PendingSyncCount: int32(len(guestLogs)),
		},
	}, nil
}

func (s *syncService) GetPendingSyncItems(ctx context.Context, deviceID string, batchSize int) (*generated.SyncBatchResponse, error) {
	if batchSize <= 0 {
		batchSize = 50
	}

	items, err := s.repo.DequeueSync(ctx, batchSize)
	if err != nil {
		return nil, fmt.Errorf("failed to get pending sync items: %w", err)
	}

	// Convert to generated types
	syncItems := make([]*generated.SyncItem, len(items))
	for i, item := range items {
		syncItems[i] = &generated.SyncItem{
			ID:            item.ID,
			TransactionID: item.ID, // Using ID as transaction ID for simplicity
			Operation:     generated.SyncOperation(item.Operation),
			TableName:     item.EntityType,
			RecordIds:     []string{item.EntityID},
			Priority:      generated.SyncPriority(item.Priority),
			Status:        generated.SyncQueueStatus(item.Status),
			DataPayload:   &item.Payload,
			CreatedAt:     item.CreatedAt,
		}
	}

	return &generated.SyncBatchResponse{
		Items:                syncItems,
		TotalPending:         int32(len(syncItems)),
		RecommendedBatchSize: int32(batchSize),
		ServerTimestamp:      time.Now(),
	}, nil
}

// =============================================================================
// SyncGuestLog - Sync individual guest log from mobile
// =============================================================================

func (s *syncService) SyncGuestLog(ctx context.Context, input generated.GuestLogSyncIndividualInput) (*generated.GuestLogSyncResult, error) {
	transactionID := uuid.New().String()
	now := time.Now()

	// Check if record already exists
	existing, err := s.repo.GetGuestLogByLocalID(ctx, input.LocalID)
	if err != nil && err != gorm.ErrRecordNotFound {
		return &generated.GuestLogSyncResult{
			Success:         false,
			ServerTimestamp: now,
			Metadata: &generated.GuestLogSyncMetadata{
				ConflictResolved: boolPtr(false),
				ExistingRecord:   boolPtr(false),
			},
		}, fmt.Errorf("database error: %w", err)
	}

	existingRecord := existing != nil
	var guestLogID string

	if existingRecord {
		// Update existing record
		updates := map[string]interface{}{
			"guest_name":    input.GuestName,
			"vehicle_plate": input.VehiclePlate,
			"status":        input.Status,
			"entry_time":    input.EntryAt,
			"sync_status":   models.SyncCompleted,
		}
		if input.GuestCompany != nil {
			updates["guest_company"] = *input.GuestCompany
		}
		if input.ExitAt != nil {
			updates["exit_time"] = *input.ExitAt
		}

		if err := s.repo.UpdateGuestLog(ctx, existing.ID, updates); err != nil {
			return &generated.GuestLogSyncResult{
				Success:         false,
				ServerTimestamp: now,
			}, fmt.Errorf("update failed: %w", err)
		}
		guestLogID = existing.ID
	} else {
		// Create new record
		newID := uuid.New().String()
		userID := middleware.GetUserFromContext(ctx)
		companyID := input.CompanyID // Use CompanyID from input

		guestLog := &models.GuestLog{
			ID:               newID,
			GuestID:          input.LocalID,
			GuestName:        input.GuestName,
			VehiclePlate:     input.VehiclePlate,
			Status:           models.GuestLogStatus(input.Status),
			EntryTime:        &input.EntryAt,
			SyncStatus:       models.SyncCompleted,
			CreatedUserID:    userID,
			AuthorizedUserID: userID,
			CompanyID:        companyID,
		}
		if input.GuestCompany != nil {
			guestLog.GuestCompany = input.GuestCompany
		}
		if input.ExitAt != nil {
			guestLog.ExitTime = input.ExitAt
		}

		if err := s.repo.CreateGuestLog(ctx, guestLog); err != nil {
			return &generated.GuestLogSyncResult{
				Success:         false,
				ServerTimestamp: now,
			}, fmt.Errorf("create failed: %w", err)
		}
		guestLogID = newID
	}

	return &generated.GuestLogSyncResult{
		Success:           true,
		GuestLogID:        &guestLogID,
		SyncTransactionID: &transactionID,
		SyncedPhotos:      int32Ptr(0),
		ServerTimestamp:   now,
		Metadata: &generated.GuestLogSyncMetadata{
			ConflictResolved: boolPtr(false),
			PhotosUploaded:   int32Ptr(0),
			ExistingRecord:   boolPtr(existingRecord),
		},
	}, nil
}

// Helper functions for pointer types
func boolPtr(b bool) *bool    { return &b }
func int32Ptr(i int32) *int32 { return &i }

// =============================================================================
// Helper Methods
// =============================================================================

func (s *syncService) errorResult(transactionID, message string, err error) (*generated.SyncResult, error) {
	return &generated.SyncResult{
		Success:       false,
		TransactionID: transactionID,
		Message:       message,
		Errors:        []string{err.Error()},
		SyncedAt:      time.Now(),
	}, nil
}

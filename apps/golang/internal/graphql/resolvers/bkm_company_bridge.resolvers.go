package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.83

import (
	"agrinovagraphql/server/internal/graphql/generated"
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/google/uuid"
	"gorm.io/gorm"
)

// CreateBkmCompanyBridge is the resolver for the createBkmCompanyBridge field.
func (r *mutationResolver) CreateBkmCompanyBridge(ctx context.Context, input generated.CreateBkmCompanyBridgeInput) (*generated.BkmCompanyBridgeRule, error) {
	sourceSystem := "BKM"
	if input.SourceSystem != nil {
		sourceSystem = strings.ToUpper(strings.TrimSpace(*input.SourceSystem))
	}
	if sourceSystem == "" {
		return nil, fmt.Errorf("sourceSystem is required")
	}

	iddataPrefix := strings.TrimSpace(input.IddataPrefix)
	if iddataPrefix == "" {
		return nil, fmt.Errorf("iddataPrefix is required")
	}

	companyID, err := normalizeRequiredUUID(input.CompanyID, "companyId")
	if err != nil {
		return nil, err
	}
	if err := r.ensureBkmBridgeCompanyExists(ctx, companyID); err != nil {
		return nil, err
	}

	priority := int32(100)
	if input.Priority != nil {
		priority = *input.Priority
	}
	if priority < 1 {
		return nil, fmt.Errorf("priority must be >= 1")
	}

	isActive := true
	if input.IsActive != nil {
		isActive = *input.IsActive
	}

	record := &bkmCompanyBridgeModel{
		ID:           uuid.NewString(),
		SourceSystem: sourceSystem,
		IddataPrefix: iddataPrefix,
		EstateKey:    normalizeNullableString(input.EstateKey),
		DivisiKey:    normalizeNullableString(input.DivisiKey),
		CompanyID:    companyID,
		Priority:     priority,
		IsActive:     isActive,
		Notes:        normalizeNullableString(input.Notes),
	}

	if err := r.db.WithContext(ctx).Create(record).Error; err != nil {
		return nil, mapBkmBridgeWriteError(err)
	}

	return r.getBkmCompanyBridgeByID(ctx, record.ID)
}

// UpdateBkmCompanyBridge is the resolver for the updateBkmCompanyBridge field.
func (r *mutationResolver) UpdateBkmCompanyBridge(ctx context.Context, input generated.UpdateBkmCompanyBridgeInput) (*generated.BkmCompanyBridgeRule, error) {
	recordID, err := normalizeRequiredUUID(input.ID, "id")
	if err != nil {
		return nil, err
	}

	var record bkmCompanyBridgeModel
	if err := r.db.WithContext(ctx).First(&record, "id = ?", recordID).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, fmt.Errorf("bkm company bridge not found")
		}
		return nil, fmt.Errorf("failed to load bkm company bridge: %w", err)
	}

	if input.SourceSystem != nil {
		sourceSystem := strings.ToUpper(strings.TrimSpace(*input.SourceSystem))
		if sourceSystem == "" {
			return nil, fmt.Errorf("sourceSystem must not be empty")
		}
		record.SourceSystem = sourceSystem
	}

	if input.IddataPrefix != nil {
		iddataPrefix := strings.TrimSpace(*input.IddataPrefix)
		if iddataPrefix == "" {
			return nil, fmt.Errorf("iddataPrefix must not be empty")
		}
		record.IddataPrefix = iddataPrefix
	}

	if input.EstateKey != nil {
		record.EstateKey = normalizeNullableString(input.EstateKey)
	}

	if input.DivisiKey != nil {
		record.DivisiKey = normalizeNullableString(input.DivisiKey)
	}

	if input.CompanyID != nil {
		companyID, err := normalizeRequiredUUID(*input.CompanyID, "companyId")
		if err != nil {
			return nil, err
		}
		if err := r.ensureBkmBridgeCompanyExists(ctx, companyID); err != nil {
			return nil, err
		}
		record.CompanyID = companyID
	}

	if input.Priority != nil {
		if *input.Priority < 1 {
			return nil, fmt.Errorf("priority must be >= 1")
		}
		record.Priority = *input.Priority
	}

	if input.IsActive != nil {
		record.IsActive = *input.IsActive
	}

	if input.Notes != nil {
		record.Notes = normalizeNullableString(input.Notes)
	}

	record.UpdatedAt = time.Now()
	if err := r.db.WithContext(ctx).Save(&record).Error; err != nil {
		return nil, mapBkmBridgeWriteError(err)
	}

	return r.getBkmCompanyBridgeByID(ctx, record.ID)
}

// DeleteBkmCompanyBridge is the resolver for the deleteBkmCompanyBridge field.
func (r *mutationResolver) DeleteBkmCompanyBridge(ctx context.Context, id string) (bool, error) {
	recordID, err := normalizeRequiredUUID(id, "id")
	if err != nil {
		return false, err
	}

	result := r.db.WithContext(ctx).Delete(&bkmCompanyBridgeModel{}, "id = ?", recordID)
	if result.Error != nil {
		return false, fmt.Errorf("failed to delete bkm company bridge: %w", result.Error)
	}
	if result.RowsAffected == 0 {
		return false, fmt.Errorf("bkm company bridge not found")
	}

	return true, nil
}

// BkmCompanyBridges is the resolver for the bkmCompanyBridges field.
func (r *queryResolver) BkmCompanyBridges(ctx context.Context, filter *generated.BkmCompanyBridgeFilterInput, page *int32, pageSize *int32) (*generated.BkmCompanyBridgeListResponse, error) {
	companyCodeColumn, err := r.resolveCompanyCodeColumn(ctx)
	if err != nil {
		return nil, err
	}

	validatedFilter := filter
	if filter != nil && filter.CompanyID != nil && strings.TrimSpace(*filter.CompanyID) != "" {
		companyID, err := normalizeRequiredUUID(*filter.CompanyID, "filter.companyId")
		if err != nil {
			return nil, err
		}
		validatedFilter = &generated.BkmCompanyBridgeFilterInput{
			Search:       filter.Search,
			CompanyID:    &companyID,
			SourceSystem: filter.SourceSystem,
			IsActive:     filter.IsActive,
		}
	}

	p := 1
	if page != nil && *page > 0 {
		p = int(*page)
	}

	l := 25
	if pageSize != nil && *pageSize > 0 {
		l = int(*pageSize)
	}
	if l > 200 {
		l = 200
	}
	offset := (p - 1) * l

	countQuery := applyBkmBridgeFilter(
		r.db.WithContext(ctx).
			Table("bkm_company_bridge bcb").
			Joins("JOIN companies c ON c.id = bcb.company_id"),
		validatedFilter,
		companyCodeColumn,
	)

	var total int64
	if err := countQuery.Count(&total).Error; err != nil {
		return nil, fmt.Errorf("failed to count bkm company bridge records: %w", err)
	}

	var rows []bkmCompanyBridgeRow
	dataQuery := applyBkmBridgeFilter(
		r.db.WithContext(ctx).
			Table("bkm_company_bridge bcb").
			Select(fmt.Sprintf(`
				bcb.id,
				bcb.source_system,
				bcb.iddata_prefix,
				bcb.estate_key,
				bcb.divisi_key,
				bcb.company_id,
				%s AS company_code,
				c.name AS company_name,
				bcb.priority,
				bcb.is_active,
				bcb.notes,
				bcb.created_at,
				bcb.updated_at
			`, companyCodeColumn)).
			Joins("JOIN companies c ON c.id = bcb.company_id"),
		validatedFilter,
		companyCodeColumn,
	)

	if err := dataQuery.
		Order("bcb.is_active DESC").
		Order("bcb.priority ASC").
		Order("bcb.source_system ASC").
		Order("bcb.iddata_prefix ASC").
		Order("bcb.updated_at DESC").
		Offset(offset).
		Limit(l).
		Scan(&rows).Error; err != nil {
		return nil, fmt.Errorf("failed to query bkm company bridge records: %w", err)
	}

	items := make([]*generated.BkmCompanyBridgeRule, 0, len(rows))
	for _, row := range rows {
		items = append(items, row.toGraphQL())
	}

	return &generated.BkmCompanyBridgeListResponse{
		Data:       items,
		TotalCount: int32(total),
		HasMore:    int64(p*l) < total,
	}, nil
}

type bkmCompanyBridgeModel struct {
	ID           string    `gorm:"column:id;primaryKey;default:gen_random_uuid()"`
	SourceSystem string    `gorm:"column:source_system"`
	IddataPrefix string    `gorm:"column:iddata_prefix"`
	EstateKey    *string   `gorm:"column:estate_key"`
	DivisiKey    *string   `gorm:"column:divisi_key"`
	CompanyID    string    `gorm:"column:company_id"`
	Priority     int32     `gorm:"column:priority"`
	IsActive     bool      `gorm:"column:is_active"`
	Notes        *string   `gorm:"column:notes"`
	CreatedAt    time.Time `gorm:"column:created_at"`
	UpdatedAt    time.Time `gorm:"column:updated_at"`
}

func (bkmCompanyBridgeModel) TableName() string {
	return "bkm_company_bridge"
}

type bkmCompanyBridgeRow struct {
	ID           string    `gorm:"column:id"`
	SourceSystem string    `gorm:"column:source_system"`
	IddataPrefix string    `gorm:"column:iddata_prefix"`
	EstateKey    *string   `gorm:"column:estate_key"`
	DivisiKey    *string   `gorm:"column:divisi_key"`
	CompanyID    string    `gorm:"column:company_id"`
	CompanyCode  *string   `gorm:"column:company_code"`
	CompanyName  *string   `gorm:"column:company_name"`
	Priority     int32     `gorm:"column:priority"`
	IsActive     bool      `gorm:"column:is_active"`
	Notes        *string   `gorm:"column:notes"`
	CreatedAt    time.Time `gorm:"column:created_at"`
	UpdatedAt    time.Time `gorm:"column:updated_at"`
}

func (r *Resolver) getBkmCompanyBridgeByID(ctx context.Context, id string) (*generated.BkmCompanyBridgeRule, error) {
	companyCodeColumn, err := r.resolveCompanyCodeColumn(ctx)
	if err != nil {
		return nil, err
	}

	var row bkmCompanyBridgeRow
	err = r.db.WithContext(ctx).
		Table("bkm_company_bridge bcb").
		Select(fmt.Sprintf(`
			bcb.id,
			bcb.source_system,
			bcb.iddata_prefix,
			bcb.estate_key,
			bcb.divisi_key,
			bcb.company_id,
			%s AS company_code,
			c.name AS company_name,
			bcb.priority,
			bcb.is_active,
			bcb.notes,
			bcb.created_at,
			bcb.updated_at
		`, companyCodeColumn)).
		Joins("JOIN companies c ON c.id = bcb.company_id").
		Where("bcb.id = ?", id).
		Take(&row).Error
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, fmt.Errorf("bkm company bridge not found")
		}
		return nil, fmt.Errorf("failed to fetch bkm company bridge: %w", err)
	}

	return row.toGraphQL(), nil
}

func (r *Resolver) ensureBkmBridgeCompanyExists(ctx context.Context, companyID string) error {
	var count int64
	if err := r.db.WithContext(ctx).Table("companies").Where("id = ?", companyID).Count(&count).Error; err != nil {
		return fmt.Errorf("failed to validate company: %w", err)
	}
	if count == 0 {
		return fmt.Errorf("company not found")
	}
	return nil
}

func (row bkmCompanyBridgeRow) toGraphQL() *generated.BkmCompanyBridgeRule {
	return &generated.BkmCompanyBridgeRule{
		ID:           row.ID,
		SourceSystem: row.SourceSystem,
		IddataPrefix: row.IddataPrefix,
		EstateKey:    row.EstateKey,
		DivisiKey:    row.DivisiKey,
		CompanyID:    row.CompanyID,
		CompanyCode:  row.CompanyCode,
		CompanyName:  row.CompanyName,
		Priority:     row.Priority,
		IsActive:     row.IsActive,
		Notes:        row.Notes,
		CreatedAt:    row.CreatedAt,
		UpdatedAt:    row.UpdatedAt,
	}
}

func applyBkmBridgeFilter(query *gorm.DB, filter *generated.BkmCompanyBridgeFilterInput, companyCodeColumn string) *gorm.DB {
	if filter == nil {
		return query
	}

	if filter.Search != nil && strings.TrimSpace(*filter.Search) != "" {
		keyword := "%" + strings.TrimSpace(*filter.Search) + "%"
		query = query.Where(fmt.Sprintf(`
			(
				%s ILIKE ?
				OR c.name ILIKE ?
				OR bcb.source_system ILIKE ?
				OR bcb.iddata_prefix ILIKE ?
				OR COALESCE(bcb.estate_key, '') ILIKE ?
				OR COALESCE(bcb.divisi_key, '') ILIKE ?
				OR COALESCE(bcb.notes, '') ILIKE ?
			)
		`, companyCodeColumn), keyword, keyword, keyword, keyword, keyword, keyword, keyword)
	}

	if filter.CompanyID != nil && strings.TrimSpace(*filter.CompanyID) != "" {
		query = query.Where("bcb.company_id = ?", strings.TrimSpace(*filter.CompanyID))
	}

	if filter.SourceSystem != nil && strings.TrimSpace(*filter.SourceSystem) != "" {
		query = query.Where("UPPER(TRIM(COALESCE(bcb.source_system, ''))) = ?", strings.ToUpper(strings.TrimSpace(*filter.SourceSystem)))
	}

	if filter.IsActive != nil {
		query = query.Where("bcb.is_active = ?", *filter.IsActive)
	}

	return query
}

func (r *Resolver) resolveCompanyCodeColumn(ctx context.Context) (string, error) {
	type columnResult struct {
		Exists bool `gorm:"column:exists"`
	}

	var hasCompanyCode columnResult
	if err := r.db.WithContext(ctx).Raw(`
		SELECT EXISTS (
			SELECT 1
			FROM information_schema.columns
			WHERE table_schema = CURRENT_SCHEMA()
			  AND table_name = 'companies'
			  AND column_name = 'company_code'
		) AS exists
	`).Scan(&hasCompanyCode).Error; err != nil {
		return "", fmt.Errorf("failed to inspect companies.company_code column: %w", err)
	}
	if hasCompanyCode.Exists {
		return "c.company_code", nil
	}

	var hasCode columnResult
	if err := r.db.WithContext(ctx).Raw(`
		SELECT EXISTS (
			SELECT 1
			FROM information_schema.columns
			WHERE table_schema = CURRENT_SCHEMA()
			  AND table_name = 'companies'
			  AND column_name = 'code'
		) AS exists
	`).Scan(&hasCode).Error; err != nil {
		return "", fmt.Errorf("failed to inspect companies.code column: %w", err)
	}
	if hasCode.Exists {
		return "c.code", nil
	}

	return "", fmt.Errorf("companies table has neither company_code nor code column")
}

func normalizeNullableString(value *string) *string {
	if value == nil {
		return nil
	}
	normalized := strings.TrimSpace(*value)
	if normalized == "" {
		return nil
	}
	return &normalized
}

func mapBkmBridgeWriteError(err error) error {
	if err == nil {
		return nil
	}

	lower := strings.ToLower(err.Error())
	if strings.Contains(lower, "invalid input syntax for type uuid") {
		return fmt.Errorf("id/companyId harus UUID valid")
	}
	if strings.Contains(lower, "uq_bkm_company_bridge_active_rule") || strings.Contains(lower, "duplicate key value") {
		return fmt.Errorf("rule aktif dengan kombinasi yang sama sudah ada")
	}
	if strings.Contains(lower, "fk_bkm_company_bridge_company") || strings.Contains(lower, "foreign key") {
		return fmt.Errorf("companyId tidak valid")
	}

	return fmt.Errorf("failed to save bkm company bridge: %w", err)
}

func normalizeRequiredUUID(raw string, fieldName string) (string, error) {
	trimmed := strings.TrimSpace(raw)
	if trimmed == "" {
		return "", fmt.Errorf("%s is required", fieldName)
	}
	parsed, err := uuid.Parse(trimmed)
	if err != nil {
		return "", fmt.Errorf("%s must be a valid UUID", fieldName)
	}
	if parsed == uuid.Nil {
		return "", fmt.Errorf("%s must not be nil UUID", fieldName)
	}
	return parsed.String(), nil
}

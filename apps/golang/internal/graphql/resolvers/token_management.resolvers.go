package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.83

import (
	authmodels "agrinovagraphql/server/internal/auth/models"
	"agrinovagraphql/server/internal/graphql/generated"
	"context"
	"time"

	"github.com/google/uuid"
)

// RevokeJWTToken is the resolver for the revokeJWTToken field.
func (r *mutationResolver) RevokeJWTToken(ctx context.Context, tokenID uuid.UUID) (*generated.RevokeJWTTokenResponse, error) {
	if _, err := requireSuperAdmin(ctx); err != nil {
		return nil, err
	}

	result := r.db.WithContext(ctx).
		Model(&authmodels.JWTToken{}).
		Where("id = ? AND is_revoked = ?", tokenID.String(), false).
		Updates(map[string]interface{}{
			"is_revoked": true,
			"revoked_at": time.Now(),
			"updated_at": time.Now(),
		})
	if result.Error != nil {
		return nil, result.Error
	}

	if result.RowsAffected == 0 {
		return &generated.RevokeJWTTokenResponse{
			Success: false,
			Message: "Token tidak ditemukan atau sudah direvoke",
		}, nil
	}

	return &generated.RevokeJWTTokenResponse{
		Success: true,
		Message: "Token berhasil direvoke",
	}, nil
}

// JwtTokens is the resolver for the jwtTokens field.
func (r *queryResolver) JwtTokens(ctx context.Context, filter *generated.JWTTokenFilterInput) ([]*generated.JWTTokenRecord, error) {
	if _, err := requireSuperAdmin(ctx); err != nil {
		return nil, err
	}

	query := r.db.WithContext(ctx).
		Model(&authmodels.JWTToken{}).
		Preload("User")

	if filter != nil {
		if filter.UserID != nil {
			query = query.Where("user_id = ?", filter.UserID.String())
		}
		if filter.DeviceID != nil && *filter.DeviceID != "" {
			query = query.Where("device_id = ?", *filter.DeviceID)
		}
		if filter.TokenType != nil && *filter.TokenType != "" {
			query = query.Where("token_type = ?", *filter.TokenType)
		}
		if filter.IsRevoked != nil {
			query = query.Where("is_revoked = ?", *filter.IsRevoked)
		}
		if filter.ActiveOnly != nil && *filter.ActiveOnly {
			now := time.Now()
			query = query.Where(
				"is_revoked = ? AND (expires_at > ? OR refresh_expires_at > ? OR offline_expires_at > ?)",
				false,
				now,
				now,
				now,
			)
		}
	}

	var tokens []authmodels.JWTToken
	if err := query.Order("created_at DESC").Find(&tokens).Error; err != nil {
		return nil, err
	}

	result := make([]*generated.JWTTokenRecord, 0, len(tokens))
	for _, token := range tokens {
		user := &token.User
		if user == nil || user.ID == "" {
			fallbackUser, err := r.AuthResolver.GetUserByID(ctx, token.UserID)
			if err == nil && fallbackUser != nil {
				user = fallbackUser
			}
		}
		if user == nil {
			continue
		}

		// Keep GraphQL Time! contract for expiresAt even when legacy rows have NULL/zero expires_at.
		expiresAt := token.ExpiresAt
		if expiresAt.IsZero() {
			switch {
			case token.RefreshExpiresAt != nil && !token.RefreshExpiresAt.IsZero():
				expiresAt = *token.RefreshExpiresAt
			case token.OfflineExpiresAt != nil && !token.OfflineExpiresAt.IsZero():
				expiresAt = *token.OfflineExpiresAt
			case !token.CreatedAt.IsZero():
				expiresAt = token.CreatedAt
			default:
				expiresAt = time.Now()
			}
		}

		result = append(result, &generated.JWTTokenRecord{
			ID:               mustParseUUID(token.ID),
			User:             user,
			UserID:           mustParseUUID(token.UserID),
			DeviceID:         token.DeviceID,
			TokenType:        string(token.TokenType),
			ExpiresAt:        expiresAt,
			RefreshExpiresAt: token.RefreshExpiresAt,
			OfflineExpiresAt: token.OfflineExpiresAt,
			IsRevoked:        token.IsRevoked,
			RevokedAt:        token.RevokedAt,
			LastUsedAt:       token.LastUsedAt,
			CreatedAt:        token.CreatedAt,
			UpdatedAt:        token.UpdatedAt,
		})
	}

	return result, nil
}

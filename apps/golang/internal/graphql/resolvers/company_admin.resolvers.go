package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.83

import (
	"agrinovagraphql/server/internal/graphql/domain/auth"
	"agrinovagraphql/server/internal/graphql/generated"
	"agrinovagraphql/server/internal/middleware"
	"context"
	"fmt"
	"time"
)

// CreateCompanyUser is the resolver for the createCompanyUser field.
func (r *mutationResolver) CreateCompanyUser(ctx context.Context, input generated.CreateCompanyUserInput) (*generated.UserManagementResult, error) {
	// 1. Validate requester is COMPANY_ADMIN and get their company
	requesterCompanyID := middleware.GetCompanyFromContext(ctx)
	if requesterCompanyID == "" {
		return &generated.UserManagementResult{
			Success: false,
			Message: "Unauthorized: Company information missing from context",
		}, nil
	}

	// 2. Validate role management rules
	allowedRoles := map[string]bool{
		string(auth.UserRoleManager):   true,
		string(auth.UserRoleAsisten):   true,
		string(auth.UserRoleMandor):    true,
		string(auth.UserRoleSatpam):    true,
		string(auth.UserRoleTimbangan): true,
		string(auth.UserRoleGrading):   true,
	}

	if !allowedRoles[input.Role] {
		return &generated.UserManagementResult{
			Success: false,
			Message: fmt.Sprintf("Forbidden: COMPANY_ADMIN cannot manage role %s", input.Role),
		}, nil
	}

	// 3. Validate assignment rules based on role
	switch input.Role {
	case string(auth.UserRoleManager):
		// MANAGER: Multi-Estate allowed, no specific count check needed (>= 0)
	case string(auth.UserRoleAsisten), string(auth.UserRoleMandor):
		// ASISTEN/MANDOR: Enforce Single Estate
		if len(input.EstateIds) != 1 {
			return &generated.UserManagementResult{
				Success: false,
				Message: "Forbidden: ASISTEN or MANDOR must be assigned to exactly one estate",
			}, nil
		}
	case string(auth.UserRoleSatpam), string(auth.UserRoleTimbangan), string(auth.UserRoleGrading):
		// SATPAM/TIMBANGAN/GRADING: Enforce Company only (No Estate/Division)
		if len(input.EstateIds) > 0 || len(input.DivisionIds) > 0 {
			return &generated.UserManagementResult{
				Success: false,
				Message: "Forbidden: SATPAM, TIMBANGAN, or GRADING cannot have estate or division assignments",
			}, nil
		}
	}

	// 4. Map to Auth domain input
	createInput := auth.CreateUserInput{
		Username:    input.Username,
		Name:        input.FullName,
		Email:       input.Email,
		PhoneNumber: input.Phone,
		Role:        auth.UserRole(input.Role),
		CompanyIDs:  []string{requesterCompanyID},
		EstateIDs:   input.EstateIds,
		DivisionIDs: input.DivisionIds,
		ManagerID:   input.ManagerID,
		Password:    input.Password,
		IsActive:    nil, // Default active if nil in auth service
	}

	// 5. Call AuthResolver
	user, err := r.AuthResolver.CreateUser(ctx, createInput)
	if err != nil {
		return &generated.UserManagementResult{
			Success: false,
			Message: err.Error(),
		}, nil
	}

	return &generated.UserManagementResult{
		Success: true,
		Message: "User created successfully",
		User:    r.mapToCompanyUser(user),
	}, nil
}

// UpdateCompanyUser is the resolver for the updateCompanyUser field.
func (r *mutationResolver) UpdateCompanyUser(ctx context.Context, input generated.UpdateCompanyUserInput) (*generated.UserManagementResult, error) {
	// 1. Validate requester is COMPANY_ADMIN and get their company
	requesterCompanyID := middleware.GetCompanyFromContext(ctx)
	if requesterCompanyID == "" {
		return &generated.UserManagementResult{
			Success: false,
			Message: "Unauthorized: Company information missing from context",
		}, nil
	}

	// 2. Validate role management rules if role is being updated
	if input.Role != nil {
		allowedRoles := map[string]bool{
			string(auth.UserRoleManager):   true,
			string(auth.UserRoleAsisten):   true,
			string(auth.UserRoleMandor):    true,
			string(auth.UserRoleSatpam):    true,
			string(auth.UserRoleTimbangan): true,
			string(auth.UserRoleGrading):   true,
		}

		if !allowedRoles[*input.Role] {
			return &generated.UserManagementResult{
				Success: false,
				Message: fmt.Sprintf("Forbidden: COMPANY_ADMIN cannot manage role %s", *input.Role),
			}, nil
		}
	}

	// 3. Map to Auth domain input
	var role *auth.UserRole
	if input.Role != nil {
		r := auth.UserRole(*input.Role)
		role = &r
	}

	updateInput := auth.UpdateUserInput{
		ID:          input.UserID,
		Email:       input.Email,
		PhoneNumber: input.Phone,
		Name:        input.FullName,
		Role:        role,
		IsActive:    input.IsActive,
		ManagerID:   input.ManagerID,
		// Company Admin cannot change company of user usually, or restricted to current company
		CompanyIDs: []string{requesterCompanyID},
	}

	// 4. Call AuthResolver
	user, err := r.AuthResolver.UpdateUser(ctx, updateInput)
	if err != nil {
		return &generated.UserManagementResult{
			Success: false,
			Message: err.Error(),
		}, nil
	}

	return &generated.UserManagementResult{
		Success: true,
		Message: "User updated successfully",
		User:    r.mapToCompanyUser(user),
	}, nil
}

// mapToCompanyUser maps auth.User to generated.CompanyUser
func (r *Resolver) mapToCompanyUser(u *auth.User) *generated.CompanyUser {
	if u == nil {
		return nil
	}

	return &generated.CompanyUser{
		ID:        u.ID,
		Username:  u.Username,
		Email:     u.Email,
		Phone:     u.PhoneNumber,
		FullName:  u.Name,
		Role:      string(u.Role),
		IsActive:  u.IsActive,
		IsOnline:  false, // Default
		LastLogin: nil,   // Optional
		Assignments: &auth.UserAssignmentSummary{
			EstateNames:   []string{},
			DivisionNames: []string{},
		},
		CreatedAt: u.CreatedAt,
	}
}

// DeleteCompanyUser is the resolver for the deleteCompanyUser field.
func (r *mutationResolver) DeleteCompanyUser(ctx context.Context, userID string) (*generated.UserManagementResult, error) {
	panic(fmt.Errorf("not implemented: DeleteCompanyUser - deleteCompanyUser"))
}

// ActivateUser is the resolver for the activateUser field.
func (r *mutationResolver) ActivateUser(ctx context.Context, userID string) (*generated.UserManagementResult, error) {
	panic(fmt.Errorf("not implemented: ActivateUser - activateUser"))
}

// DeactivateUser is the resolver for the deactivateUser field.
func (r *mutationResolver) DeactivateUser(ctx context.Context, userID string, reason *string) (*generated.UserManagementResult, error) {
	panic(fmt.Errorf("not implemented: DeactivateUser - deactivateUser"))
}

// AdminResetUserPassword is the resolver for the adminResetUserPassword field.
func (r *mutationResolver) AdminResetUserPassword(ctx context.Context, userID string, newPassword *string, sendEmail *bool) (*generated.UserManagementResult, error) {
	panic(fmt.Errorf("not implemented: AdminResetUserPassword - adminResetUserPassword"))
}

// UnlockUserAccount is the resolver for the unlockUserAccount field.
func (r *mutationResolver) UnlockUserAccount(ctx context.Context, userID string) (*generated.UserManagementResult, error) {
	panic(fmt.Errorf("not implemented: UnlockUserAccount - unlockUserAccount"))
}

// AssignUserToEstateAdmin is the resolver for the assignUserToEstateAdmin field.
func (r *mutationResolver) AssignUserToEstateAdmin(ctx context.Context, userID string, estateID string) (*generated.UserManagementResult, error) {
	panic(fmt.Errorf("not implemented: AssignUserToEstateAdmin - assignUserToEstateAdmin"))
}

// RemoveUserFromEstateAdmin is the resolver for the removeUserFromEstateAdmin field.
func (r *mutationResolver) RemoveUserFromEstateAdmin(ctx context.Context, userID string, estateID string) (*generated.UserManagementResult, error) {
	panic(fmt.Errorf("not implemented: RemoveUserFromEstateAdmin - removeUserFromEstateAdmin"))
}

// AssignUserToDivisionAdmin is the resolver for the assignUserToDivisionAdmin field.
func (r *mutationResolver) AssignUserToDivisionAdmin(ctx context.Context, userID string, divisionID string) (*generated.UserManagementResult, error) {
	panic(fmt.Errorf("not implemented: AssignUserToDivisionAdmin - assignUserToDivisionAdmin"))
}

// RemoveUserFromDivisionAdmin is the resolver for the removeUserFromDivisionAdmin field.
func (r *mutationResolver) RemoveUserFromDivisionAdmin(ctx context.Context, userID string, divisionID string) (*generated.UserManagementResult, error) {
	panic(fmt.Errorf("not implemented: RemoveUserFromDivisionAdmin - removeUserFromDivisionAdmin"))
}

// UpdateCompanySettings is the resolver for the updateCompanySettings field.
func (r *mutationResolver) UpdateCompanySettings(ctx context.Context, input generated.UpdateCompanySettingsInput) (*generated.CompanySettings, error) {
	panic(fmt.Errorf("not implemented: UpdateCompanySettings - updateCompanySettings"))
}

// CompanyAdminDashboard is the resolver for the companyAdminDashboard field.
func (r *queryResolver) CompanyAdminDashboard(ctx context.Context) (*generated.CompanyAdminDashboardData, error) {
	panic(fmt.Errorf("not implemented: CompanyAdminDashboard - companyAdminDashboard"))
}

// CompanyUsers is the resolver for the companyUsers field.
func (r *queryResolver) CompanyUsers(ctx context.Context, filter *generated.UserFilterInput) (*generated.CompanyUserListResponse, error) {
	panic(fmt.Errorf("not implemented: CompanyUsers - companyUsers"))
}

// CompanyUser is the resolver for the companyUser field.
func (r *queryResolver) CompanyUser(ctx context.Context, userID string) (*generated.CompanyUser, error) {
	panic(fmt.Errorf("not implemented: CompanyUser - companyUser"))
}

// CompanySettings is the resolver for the companySettings field.
func (r *queryResolver) CompanySettings(ctx context.Context) (*generated.CompanySettings, error) {
	panic(fmt.Errorf("not implemented: CompanySettings - companySettings"))
}

// AdminActivityLogs is the resolver for the adminActivityLogs field.
func (r *queryResolver) AdminActivityLogs(ctx context.Context, activityType *generated.AdminActivityType, userID *string, dateFrom *time.Time, dateTo *time.Time, limit *int32) ([]*generated.AdminActivityLog, error) {
	panic(fmt.Errorf("not implemented: AdminActivityLogs - adminActivityLogs"))
}

// UserStatistics is the resolver for the userStatistics field.
func (r *queryResolver) UserStatistics(ctx context.Context) (*generated.UserOverview, error) {
	panic(fmt.Errorf("not implemented: UserStatistics - userStatistics"))
}

// UserStatusChange is the resolver for the userStatusChange field.
func (r *subscriptionResolver) UserStatusChange(ctx context.Context) (<-chan *generated.CompanyUser, error) {
	panic(fmt.Errorf("not implemented: UserStatusChange - userStatusChange"))
}

// NewAdminActivity is the resolver for the newAdminActivity field.
func (r *subscriptionResolver) NewAdminActivity(ctx context.Context) (<-chan *generated.AdminActivityLog, error) {
	panic(fmt.Errorf("not implemented: NewAdminActivity - newAdminActivity"))
}

// SystemHealthChange is the resolver for the systemHealthChange field.
func (r *subscriptionResolver) SystemHealthChange(ctx context.Context) (<-chan *generated.SystemHealthData, error) {
	panic(fmt.Errorf("not implemented: SystemHealthChange - systemHealthChange"))
}

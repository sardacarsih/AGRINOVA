package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"agrinovagraphql/server/internal/graphql/domain/auth"
	"agrinovagraphql/server/internal/graphql/domain/common"
	"agrinovagraphql/server/internal/graphql/domain/master"
	"agrinovagraphql/server/internal/graphql/generated"
	"context"
	"fmt"
)

// User returns generated.UserResolver implementation.
func (r *Resolver) User() generated.UserResolver { return &userResolver{r} }

type userResolver struct{ *Resolver }

// CompanyID is the resolver for the companyId field.
func (r *userResolver) CompanyID(ctx context.Context, obj *auth.User) (*string, error) {
	if len(obj.Assignments) > 0 {
		// Return first active assignment
		for _, a := range obj.Assignments {
			if a.IsActive {
				return &a.CompanyID, nil
			}
		}
		// If no active, return first one
		return &obj.Assignments[0].CompanyID, nil
	}
	return nil, nil
}

// Company is the resolver for the company field.
func (r *userResolver) Company(ctx context.Context, obj *auth.User) (*master.Company, error) {
	if len(obj.Assignments) > 0 {
		// Return first active assignment
		for _, a := range obj.Assignments {
			if a.IsActive {
				if a.Company != nil {
					return a.Company, nil
				}
				if a.CompanyID != "" && r.db != nil {
					var company master.Company
					if err := r.db.WithContext(ctx).Unscoped().First(&company, "id = ?", a.CompanyID).Error; err == nil {
						return &company, nil
					}
				}
				return nil, nil
			}
		}
		// If no active, return first one
		if obj.Assignments[0].Company != nil {
			return obj.Assignments[0].Company, nil
		}
		if obj.Assignments[0].CompanyID != "" && r.db != nil {
			var company master.Company
			if err := r.db.WithContext(ctx).Unscoped().First(&company, "id = ?", obj.Assignments[0].CompanyID).Error; err == nil {
				return &company, nil
			}
		}
		return nil, nil
	}
	return nil, nil
}

// Companies is the resolver for the companies field.
func (r *userResolver) Companies(ctx context.Context, obj *auth.User) ([]*master.Company, error) {
	companies := make([]*master.Company, 0)
	seen := make(map[string]struct{})

	addCompany := func(assignment auth.UserCompanyAssignment) {
		if assignment.CompanyID == "" {
			return
		}
		if _, exists := seen[assignment.CompanyID]; exists {
			return
		}
		if assignment.Company != nil {
			companies = append(companies, assignment.Company)
			seen[assignment.CompanyID] = struct{}{}
			return
		}
		if r.db != nil {
			var company master.Company
			if err := r.db.WithContext(ctx).Unscoped().First(&company, "id = ?", assignment.CompanyID).Error; err == nil {
				companies = append(companies, &company)
				seen[assignment.CompanyID] = struct{}{}
			}
		}
	}

	if len(obj.Assignments) > 0 {
		for _, assignment := range obj.Assignments {
			if !assignment.IsActive {
				continue
			}
			addCompany(assignment)
		}
		// Fallback: if no active assignments, include any assignment to avoid empty list
		if len(companies) == 0 {
			for _, assignment := range obj.Assignments {
				addCompany(assignment)
			}
		}
	}

	return companies, nil
}

// WebLogin is the resolver for the webLogin field.
func (r *mutationResolver) WebLogin(ctx context.Context, input auth.WebLoginInput) (*auth.WebLoginPayload, error) {
	return r.AuthResolver.WebLogin(ctx, input)
}

// MobileLogin is the resolver for the mobileLogin field.
func (r *mutationResolver) MobileLogin(ctx context.Context, input auth.MobileLoginInput) (*auth.AuthPayload, error) {
	return r.AuthResolver.MobileLogin(ctx, input)
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, input auth.RefreshTokenInput) (*auth.AuthPayload, error) {
	return r.AuthResolver.RefreshToken(ctx, input)
}

// DeviceRenew is the resolver for the deviceRenew field.
func (r *mutationResolver) DeviceRenew(ctx context.Context, input generated.DeviceRenewInput) (*auth.AuthPayload, error) {
	return r.AuthResolver.DeviceRenew(ctx, auth.DeviceRenewInput{
		OfflineToken:      input.OfflineToken,
		DeviceID:          input.DeviceID,
		DeviceFingerprint: input.DeviceFingerprint,
	})
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (bool, error) {
	return r.AuthResolver.Logout(ctx)
}

// LogoutAllDevices is the resolver for the logoutAllDevices field.
func (r *mutationResolver) LogoutAllDevices(ctx context.Context) (bool, error) {
	return r.AuthResolver.LogoutAllDevices(ctx)
}

// ChangePassword is the resolver for the changePassword field.
func (r *mutationResolver) ChangePassword(ctx context.Context, input auth.ChangePasswordInput) (bool, error) {
	return r.AuthResolver.ChangePassword(ctx, input)
}

// BindDevice is the resolver for the bindDevice field.
func (r *mutationResolver) BindDevice(ctx context.Context, input auth.DeviceBindInput) (*auth.DeviceResponse, error) {
	return r.AuthResolver.BindDevice(ctx, input)
}

// UnbindDevice is the resolver for the unbindDevice field.
func (r *mutationResolver) UnbindDevice(ctx context.Context, deviceID string) (bool, error) {
	return r.AuthResolver.UnbindDevice(ctx, deviceID)
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input auth.CreateUserInput) (*auth.UserMutationResponse, error) {
	user, err := r.AuthResolver.CreateUser(ctx, input)
	if err != nil {
		return &auth.UserMutationResponse{
			Success: false,
			Message: err.Error(),
			User:    nil,
		}, err
	}

	return &auth.UserMutationResponse{
		Success: true,
		Message: "User created successfully",
		User:    user,
	}, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input auth.UpdateUserInput) (*auth.UserMutationResponse, error) {
	user, err := r.AuthResolver.UpdateUser(ctx, input)
	if err != nil {
		return &auth.UserMutationResponse{
			Success: false,
			Message: err.Error(),
			User:    nil,
		}, err
	}

	return &auth.UserMutationResponse{
		Success: true,
		Message: "User updated successfully",
		User:    user,
	}, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (*auth.UserMutationResponse, error) {
	success, err := r.AuthResolver.DeleteUser(ctx, id)
	if err != nil {
		return &auth.UserMutationResponse{
			Success: false,
			Message: err.Error(),
			User:    nil,
		}, err
	}

	if !success {
		return &auth.UserMutationResponse{
			Success: false,
			Message: "Failed to delete user",
			User:    nil,
		}, nil
	}

	return &auth.UserMutationResponse{
		Success: true,
		Message: "User deleted successfully",
		User:    nil,
	}, nil
}

// ResetUserPassword is the resolver for the resetUserPassword field.
func (r *mutationResolver) ResetUserPassword(ctx context.Context, input auth.ResetPasswordInput) (*auth.UserMutationResponse, error) {
	success, err := r.AuthResolver.ResetUserPassword(ctx, input)
	if err != nil {
		return &auth.UserMutationResponse{
			Success: false,
			Message: err.Error(),
			User:    nil,
		}, err
	}

	if !success {
		return &auth.UserMutationResponse{
			Success: false,
			Message: "Failed to reset user password",
			User:    nil,
		}, nil
	}

	return &auth.UserMutationResponse{
		Success: true,
		Message: "User password reset successfully",
		User:    nil,
	}, nil
}

// ToggleUserStatus is the resolver for the toggleUserStatus field.
func (r *mutationResolver) ToggleUserStatus(ctx context.Context, id string) (*auth.UserMutationResponse, error) {
	user, err := r.AuthResolver.ToggleUserStatus(ctx, id)
	if err != nil {
		return &auth.UserMutationResponse{
			Success: false,
			Message: err.Error(),
			User:    nil,
		}, err
	}

	status := "activated"
	if !user.IsActive {
		status = "deactivated"
	}

	return &auth.UserMutationResponse{
		Success: true,
		Message: fmt.Sprintf("User %s successfully", status),
		User:    user,
	}, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*auth.User, error) {
	return r.AuthResolver.Me(ctx)
}

// CurrentUser is the resolver for the currentUser field.
func (r *queryResolver) CurrentUser(ctx context.Context) (*auth.WebLoginPayload, error) {
	return r.AuthResolver.CurrentUser(ctx)
}

// MyDevices is the resolver for the myDevices field.
func (r *queryResolver) MyDevices(ctx context.Context) ([]*auth.Device, error) {
	return r.AuthResolver.MyDevices(ctx)
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, companyID *string, role *auth.UserRole, isActive *bool, search *string, limit *int32, offset *int32) (*generated.UserListResponse, error) {
	users, total, err := r.AuthResolver.GetUsers(ctx, companyID, role, isActive, search, limit, offset)
	if err != nil {
		return nil, err
	}

	// Create page info
	page := int32(1)
	if offset != nil && limit != nil && *limit > 0 {
		page = (*offset / *limit) + 1
	}

	totalPages := int32(1)
	if limit != nil && *limit > 0 {
		totalPages = (int32(total) + *limit - 1) / *limit
	}

	pageInfo := &common.PageInfo{
		CurrentPage:     page,
		TotalPages:      totalPages,
		HasNextPage:     page < totalPages,
		HasPreviousPage: page > 1,
	}

	return &generated.UserListResponse{
		Users:       users,
		TotalCount:  int32(total),
		HasNextPage: pageInfo.HasNextPage,
		PageInfo:    pageInfo,
	}, nil
}

// UsersByCompany is the resolver for the usersByCompany field.
func (r *queryResolver) UsersByCompany(ctx context.Context, companyID string) ([]*auth.User, error) {
	return r.AuthResolver.GetUsersByCompany(ctx, companyID)
}

// UsersByRole is the resolver for the usersByRole field.
func (r *queryResolver) UsersByRole(ctx context.Context, role auth.UserRole) ([]*auth.User, error) {
	return r.AuthResolver.GetUsersByRole(ctx, role)
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*auth.User, error) {
	return r.AuthResolver.GetUserByID(ctx, id)
}

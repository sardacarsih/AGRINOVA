package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"agrinovagraphql/server/internal/graphql/domain/auth"
	"agrinovagraphql/server/internal/graphql/domain/rbac"
	"agrinovagraphql/server/internal/graphql/generated"
	rbacModels "agrinovagraphql/server/internal/rbac/models"
	"context"
	"fmt"
	"time"

	"github.com/google/uuid"
)

// ============================================================================
// MUTATION RESOLVERS
// ============================================================================

// AssignRolePermissions is the resolver for the assignRolePermissions field.
func (r *mutationResolver) AssignRolePermissions(ctx context.Context, input rbac.RolePermissionInput) (*rbac.Role, error) {
	// Convert input to domain model
	domainInput := rbacModels.RolePermissionInput{
		RoleName:    input.RoleName,
		Permissions: input.Permissions,
	}
	if input.InheritFrom != nil {
		domainInput.InheritFrom = input.InheritFrom
	}

	// Call domain resolver
	role, err := r.RBACResolver.AssignRolePermissions(ctx, domainInput)
	if err != nil {
		return nil, err
	}

	// Convert to GraphQL type
	return convertRoleToGraphQL(role), nil
}

// RemoveRolePermissions is the resolver for the removeRolePermissions field.
func (r *mutationResolver) RemoveRolePermissions(ctx context.Context, roleName string, permissions []string) (*rbac.Role, error) {
	role, err := r.RBACResolver.RemoveRolePermissions(ctx, roleName, permissions)
	if err != nil {
		return nil, err
	}

	return convertRoleToGraphQL(role), nil
}

// CreateRole is the resolver for the createRole field.
func (r *mutationResolver) CreateRole(ctx context.Context, name string, displayName string, level int32, description *string) (*rbac.Role, error) {
	role, err := r.RBACResolver.CreateRole(ctx, name, displayName, int(level), description)
	if err != nil {
		return nil, err
	}

	return convertRoleToGraphQL(role), nil
}

// UpdateRole is the resolver for the updateRole field.
func (r *mutationResolver) UpdateRole(ctx context.Context, name string, displayName *string, description *string, isActive *bool) (*rbac.Role, error) {
	role, err := r.RBACResolver.UpdateRole(ctx, name, displayName, description, isActive)
	if err != nil {
		return nil, err
	}

	return convertRoleToGraphQL(role), nil
}

// DeleteRole is the resolver for the deleteRole field.
func (r *mutationResolver) DeleteRole(ctx context.Context, name string) (bool, error) {
	return r.RBACResolver.DeleteRole(ctx, name)
}

// CreatePermission is the resolver for the createPermission field.
func (r *mutationResolver) CreatePermission(ctx context.Context, name string, resource string, action string, description *string) (*rbac.Permission, error) {
	perm, err := r.RBACResolver.CreatePermission(ctx, name, resource, action, description)
	if err != nil {
		return nil, err
	}

	return convertPermissionToGraphQL(perm), nil
}

// UpdatePermission is the resolver for the updatePermission field.
func (r *mutationResolver) UpdatePermission(ctx context.Context, name string, description *string, isActive *bool) (*rbac.Permission, error) {
	perm, err := r.RBACResolver.UpdatePermission(ctx, name, description, isActive)
	if err != nil {
		return nil, err
	}

	return convertPermissionToGraphQL(perm), nil
}

// DeletePermission is the resolver for the deletePermission field.
func (r *mutationResolver) DeletePermission(ctx context.Context, name string) (bool, error) {
	return r.RBACResolver.DeletePermission(ctx, name)
}

// AssignUserPermission is the resolver for the assignUserPermission field.
func (r *mutationResolver) AssignUserPermission(ctx context.Context, input generated.UserPermissionInput) (*generated.UserPermissionAssignment, error) {
	// Convert input to domain model
	domainInput := rbacModels.UserPermissionInput{
		UserID:     input.UserID,
		Permission: input.Permission,
		IsGranted:  input.IsGranted,
	}
	if input.Scope != nil {
		domainInput.Scope = &rbacModels.PermissionScope{
			Type: input.Scope.Type,
			ID:   input.Scope.ID,
		}
	}
	if input.ExpiresAt != nil {
		domainInput.ExpiresAt = input.ExpiresAt
	}

	assignment, err := r.RBACResolver.AssignUserPermission(ctx, domainInput)
	if err != nil {
		return nil, err
	}

	return convertUserPermissionAssignmentToGraphQL(assignment), nil
}

// RemoveUserPermission is the resolver for the removeUserPermission field.
func (r *mutationResolver) RemoveUserPermission(ctx context.Context, userID string, permission string, scope *rbac.PermissionScopeInput) (bool, error) {
	var domainScope *rbacModels.PermissionScope
	if scope != nil {
		domainScope = &rbacModels.PermissionScope{
			Type: scope.Type,
			ID:   scope.ID,
		}
	}

	return r.RBACResolver.RemoveUserPermission(ctx, userID, permission, domainScope)
}

// ClearUserPermissions is the resolver for the clearUserPermissions field.
func (r *mutationResolver) ClearUserPermissions(ctx context.Context, userID string) (bool, error) {
	return r.RBACResolver.ClearUserPermissions(ctx, userID)
}

// AssignUserPermissions is the resolver for the assignUserPermissions field.
func (r *mutationResolver) AssignUserPermissions(ctx context.Context, userID string, permissions []*generated.UserPermissionInput) ([]*generated.UserPermissionAssignment, error) {
	// Convert inputs to domain models
	domainInputs := make([]rbacModels.UserPermissionInput, len(permissions))
	for i, perm := range permissions {
		domainInputs[i] = rbacModels.UserPermissionInput{
			UserID:     perm.UserID,
			Permission: perm.Permission,
			IsGranted:  perm.IsGranted,
		}
		if perm.Scope != nil {
			domainInputs[i].Scope = &rbacModels.PermissionScope{
				Type: perm.Scope.Type,
				ID:   perm.Scope.ID,
			}
		}
		if perm.ExpiresAt != nil {
			domainInputs[i].ExpiresAt = perm.ExpiresAt
		}
	}

	assignments, err := r.RBACResolver.AssignUserPermissions(ctx, userID, domainInputs)
	if err != nil {
		return nil, err
	}

	// Convert to GraphQL types
	graphqlAssignments := make([]*generated.UserPermissionAssignment, len(assignments))
	for i, assignment := range assignments {
		graphqlAssignments[i] = convertUserPermissionAssignmentToGraphQL(assignment)
	}

	return graphqlAssignments, nil
}

// MigrateStaticPermissions is the resolver for the migrateStaticPermissions field.
func (r *mutationResolver) MigrateStaticPermissions(ctx context.Context) (bool, error) {
	return r.RBACResolver.MigrateStaticPermissions(ctx)
}

// ============================================================================
// QUERY RESOLVERS
// ============================================================================

// RoleHierarchy is the resolver for the roleHierarchy field.
func (r *queryResolver) RoleHierarchy(ctx context.Context) ([]*rbac.Role, error) {
	roles, err := r.RBACResolver.RoleHierarchy(ctx)
	if err != nil {
		return nil, err
	}

	graphqlRoles := make([]*rbac.Role, len(roles))
	for i, role := range roles {
		graphqlRoles[i] = convertRoleToGraphQL(role)
	}

	return graphqlRoles, nil
}

// Roles is the resolver for the roles field.
func (r *queryResolver) Roles(ctx context.Context, activeOnly *bool) ([]*rbac.Role, error) {
	active := true // Default to true
	if activeOnly != nil {
		active = *activeOnly
	}

	roles, err := r.RBACResolver.Roles(ctx, active)
	if err != nil {
		return nil, err
	}

	graphqlRoles := make([]*rbac.Role, len(roles))
	for i, role := range roles {
		graphqlRoles[i] = convertRoleToGraphQL(role)
	}

	return graphqlRoles, nil
}

// Role is the resolver for the role field.
func (r *queryResolver) Role(ctx context.Context, name string) (*rbac.Role, error) {
	role, err := r.RBACResolver.Role(ctx, name)
	if err != nil {
		return nil, err
	}

	return convertRoleToGraphQL(role), nil
}

// Permissions is the resolver for the permissions field.
func (r *queryResolver) Permissions(ctx context.Context, activeOnly *bool) ([]*rbac.Permission, error) {
	active := true // Default to true
	if activeOnly != nil {
		active = *activeOnly
	}

	perms, err := r.RBACResolver.Permissions(ctx, active)
	if err != nil {
		return nil, err
	}

	graphqlPerms := make([]*rbac.Permission, len(perms))
	for i, perm := range perms {
		graphqlPerms[i] = convertPermissionToGraphQL(perm)
	}

	return graphqlPerms, nil
}

// Permission is the resolver for the permission field.
func (r *queryResolver) Permission(ctx context.Context, name string) (*rbac.Permission, error) {
	perm, err := r.RBACResolver.Permission(ctx, name)
	if err != nil {
		return nil, err
	}

	return convertPermissionToGraphQL(perm), nil
}

// RolePermissions is the resolver for the rolePermissions field.
func (r *queryResolver) RolePermissions(ctx context.Context, roleName string) ([]string, error) {
	return r.RBACResolver.RolePermissions(ctx, roleName)
}

// UserPermissions is the resolver for the userPermissions field.
func (r *queryResolver) UserPermissions(ctx context.Context, userID string) (*generated.UserPermissions, error) {
	userPerms, err := r.RBACResolver.UserPermissions(ctx, userID)
	if err != nil {
		return nil, err
	}

	// Convert overrides to GraphQL type
	graphqlOverrides := make([]*generated.UserPermissionOverride, len(userPerms.Overrides))
	for i, override := range userPerms.Overrides {
		graphqlOverride := &generated.UserPermissionOverride{
			Permission: override.Permission,
			IsGranted:  override.IsGranted,
		}
		if override.Scope != nil {
			graphqlOverride.Scope = &rbac.PermissionScope{
				Type: override.Scope.Type,
				ID:   override.Scope.ID,
			}
		}
		if override.ExpiresAt != nil {
			graphqlOverride.ExpiresAt = override.ExpiresAt
		}
		graphqlOverrides[i] = graphqlOverride
	}

	return &generated.UserPermissions{
		UserID:      userPerms.UserID,
		Role:        userPerms.Role,
		Permissions: userPerms.Permissions,
		Overrides:   graphqlOverrides,
	}, nil
}

// CheckPermission is the resolver for the checkPermission field.
func (r *queryResolver) CheckPermission(ctx context.Context, input rbac.PermissionCheckInput) (*rbac.PermissionCheckResult, error) {
	// Convert input to domain model
	domainInput := rbacModels.PermissionCheck{
		UserID:     input.UserID,
		Permission: input.Permission,
	}
	if input.Scope != nil {
		domainInput.Scope = &rbacModels.PermissionScope{
			Type: input.Scope.Type,
			ID:   input.Scope.ID,
		}
	}

	result, err := r.RBACResolver.CheckPermission(ctx, domainInput)
	if err != nil {
		return nil, err
	}

	graphqlResult := &rbac.PermissionCheckResult{
		UserID:     result.UserID,
		Permission: result.Permission,
		HasAccess:  result.HasAccess,
	}
	if result.Reason != "" {
		graphqlResult.Reason = &result.Reason
	}

	return graphqlResult, nil
}

// CheckPermissions is the resolver for the checkPermissions field.
func (r *queryResolver) CheckPermissions(ctx context.Context, input rbac.BatchPermissionCheckInput) (*rbac.BatchPermissionCheckResult, error) {
	// Convert input to domain model
	requireAll := false
	if input.RequireAll != nil {
		requireAll = *input.RequireAll
	}

	domainInput := rbacModels.BatchPermissionCheck{
		UserID:      input.UserID,
		Permissions: input.Permissions,
		RequireAll:  requireAll,
	}

	result, err := r.RBACResolver.CheckPermissions(ctx, domainInput)
	if err != nil {
		return nil, err
	}

	return &rbac.BatchPermissionCheckResult{
		UserID:            result.UserID,
		Permissions:       result.Permissions,
		HasAccess:         result.HasAccess,
		FailedPermissions: result.FailedPerms,
	}, nil
}

// CanManageRole is the resolver for the canManageRole field.
func (r *queryResolver) CanManageRole(ctx context.Context, targetRoleName string) (bool, error) {
	return r.RBACResolver.CanManageRole(ctx, targetRoleName)
}

// RbacStats is the resolver for the rbacStats field.
func (r *queryResolver) RbacStats(ctx context.Context) (*rbac.RBACStats, error) {
	stats, err := r.RBACResolver.RBACStats(ctx)
	if err != nil {
		return nil, err
	}

	// Convert cache stats map to string (optional field)
	var cacheStatsStr *string
	if stats.CacheStats != nil {
		// Simple JSON-like representation
		cacheStr := fmt.Sprintf("%v", stats.CacheStats)
		cacheStatsStr = &cacheStr
	}

	return &rbac.RBACStats{
		TotalRoles:           int32(stats.TotalRoles),
		ActiveRoles:          int32(stats.ActiveRoles),
		TotalPermissions:     int32(stats.TotalPermissions),
		ActivePermissions:    int32(stats.ActivePermissions),
		TotalRolePermissions: int32(stats.TotalRolePermissions),
		TotalUserOverrides:   int32(stats.TotalUserOverrides),
		CacheStats:           cacheStatsStr,
	}, nil
}

// UserPermissionOverrides is the resolver for the userPermissionOverrides field.
func (r *queryResolver) UserPermissionOverrides(ctx context.Context, userID string) ([]*generated.UserPermissionAssignment, error) {
	assignments, err := r.RBACResolver.UserPermissionOverrides(ctx, userID)
	if err != nil {
		return nil, err
	}

	graphqlAssignments := make([]*generated.UserPermissionAssignment, len(assignments))
	for i, assignment := range assignments {
		graphqlAssignments[i] = convertUserPermissionAssignmentToGraphQL(assignment)
	}

	return graphqlAssignments, nil
}

// ============================================================================
// ROLE HIERARCHY QUERY RESOLVERS (10)
// ============================================================================

// RbacRolesAbove is the resolver for the rbacRolesAbove field.
func (r *queryResolver) RbacRolesAbove(ctx context.Context, roleName string) ([]*rbac.Role, error) {
	roles, err := r.RBACResolver.RolesAbove(ctx, roleName)
	if err != nil {
		return nil, err
	}

	graphqlRoles := make([]*rbac.Role, len(roles))
	for i, role := range roles {
		graphqlRoles[i] = convertRoleToGraphQL(role)
	}

	return graphqlRoles, nil
}

// RbacRolesBelow is the resolver for the rbacRolesBelow field.
func (r *queryResolver) RbacRolesBelow(ctx context.Context, roleName string) ([]*rbac.Role, error) {
	roles, err := r.RBACResolver.RolesBelow(ctx, roleName)
	if err != nil {
		return nil, err
	}

	graphqlRoles := make([]*rbac.Role, len(roles))
	for i, role := range roles {
		graphqlRoles[i] = convertRoleToGraphQL(role)
	}

	return graphqlRoles, nil
}

// RbacSubordinateRoles is the resolver for the rbacSubordinateRoles field.
func (r *queryResolver) RbacSubordinateRoles(ctx context.Context, roleName string) ([]*rbac.Role, error) {
	roles, err := r.RBACResolver.SubordinateRoles(ctx, roleName)
	if err != nil {
		return nil, err
	}

	graphqlRoles := make([]*rbac.Role, len(roles))
	for i, role := range roles {
		graphqlRoles[i] = convertRoleToGraphQL(role)
	}

	return graphqlRoles, nil
}

// RbacSuperiorRoles is the resolver for the rbacSuperiorRoles field.
func (r *queryResolver) RbacSuperiorRoles(ctx context.Context, roleName string) ([]*rbac.Role, error) {
	roles, err := r.RBACResolver.SuperiorRoles(ctx, roleName)
	if err != nil {
		return nil, err
	}

	graphqlRoles := make([]*rbac.Role, len(roles))
	for i, role := range roles {
		graphqlRoles[i] = convertRoleToGraphQL(role)
	}

	return graphqlRoles, nil
}

// RbacRolesAtLevel is the resolver for the rbacRolesAtLevel field.
func (r *queryResolver) RbacRolesAtLevel(ctx context.Context, level int32) ([]*rbac.Role, error) {
	roles, err := r.RBACResolver.RolesAtLevel(ctx, int(level))
	if err != nil {
		return nil, err
	}

	graphqlRoles := make([]*rbac.Role, len(roles))
	for i, role := range roles {
		graphqlRoles[i] = convertRoleToGraphQL(role)
	}

	return graphqlRoles, nil
}

// RbacRolesByLevelRange is the resolver for the rbacRolesByLevelRange field.
func (r *queryResolver) RbacRolesByLevelRange(ctx context.Context, minLevel int32, maxLevel int32) ([]*rbac.Role, error) {
	roles, err := r.RBACResolver.RolesByLevelRange(ctx, int(minLevel), int(maxLevel))
	if err != nil {
		return nil, err
	}

	graphqlRoles := make([]*rbac.Role, len(roles))
	for i, role := range roles {
		graphqlRoles[i] = convertRoleToGraphQL(role)
	}

	return graphqlRoles, nil
}

// RbacCanRoleManage is the resolver for the rbacCanRoleManage field.
func (r *queryResolver) RbacCanRoleManage(ctx context.Context, sourceRole string, targetRole string) (bool, error) {
	return r.RBACResolver.CanRoleManage(ctx, sourceRole, targetRole)
}

// RbacRoleRelationship is the resolver for the rbacRoleRelationship field.
func (r *queryResolver) RbacRoleRelationship(ctx context.Context, sourceRole string, targetRole string) (*rbac.RoleRelationship, error) {
	relationship, err := r.RBACResolver.RoleRelationship(ctx, sourceRole, targetRole)
	if err != nil {
		return nil, err
	}

	return &rbac.RoleRelationship{
		SourceRole:      relationship.SourceRole,
		TargetRole:      relationship.TargetRole,
		CanManage:       relationship.CanManage,
		LevelDifference: int32(relationship.LevelDifference),
		Relationship:    relationship.Relationship,
	}, nil
}

// RbacEffectivePermissions is the resolver for the rbacEffectivePermissions field.
func (r *queryResolver) RbacEffectivePermissions(ctx context.Context, roleName string) ([]string, error) {
	return r.RBACResolver.EffectivePermissions(ctx, roleName)
}

// RbacHierarchyTree is the resolver for the rbacHierarchyTree field.
func (r *queryResolver) RbacHierarchyTree(ctx context.Context) ([]*rbac.RoleHierarchyNode, error) {
	nodes, err := r.RBACResolver.HierarchyTree(ctx)
	if err != nil {
		return nil, err
	}

	return convertHierarchyNodesToGraphQL(nodes), nil
}

// ============================================================================
// HELPER FUNCTIONS - Type Conversions
// ============================================================================

// convertRoleToGraphQL converts domain Role to GraphQL Role
func convertRoleToGraphQL(role *rbacModels.Role) *rbac.Role {
	graphqlRole := &rbac.Role{
		ID:          role.ID.String(),
		Name:        role.Name,
		DisplayName: role.DisplayName,
		Level:       int32(role.Level),
		IsActive:    role.IsActive,
		IsSystem:    role.IsSystem,
		CreatedAt:   role.CreatedAt,
		UpdatedAt:   role.UpdatedAt,
	}

	if role.Description != "" {
		graphqlRole.Description = &role.Description
	}

	// Convert gorm.DeletedAt to *time.Time
	if role.DeletedAt.Valid {
		deletedAt := role.DeletedAt.Time
		graphqlRole.DeletedAt = &deletedAt
	}

	return graphqlRole
}

// convertPermissionToGraphQL converts domain Permission to GraphQL Permission
func convertPermissionToGraphQL(perm *rbacModels.Permission) *rbac.Permission {
	graphqlPerm := &rbac.Permission{
		ID:        perm.ID.String(),
		Name:      perm.Name,
		Resource:  perm.Resource,
		Action:    perm.Action,
		IsActive:  perm.IsActive,
		CreatedAt: perm.CreatedAt,
	}

	if perm.Description != "" {
		graphqlPerm.Description = &perm.Description
	}

	return graphqlPerm
}

// convertUserPermissionAssignmentToGraphQL converts domain UserPermissionAssignment to GraphQL type
func convertUserPermissionAssignmentToGraphQL(assignment *rbacModels.UserPermissionAssignment) *generated.UserPermissionAssignment {
	// Note: This returns a placeholder User and Permission
	// In a full implementation, these would need to be fetched from the database
	userID := assignment.UserID.String()
	permID := assignment.PermissionID.String()
	createdByID := assignment.CreatedBy.String()

	graphqlAssignment := &generated.UserPermissionAssignment{
		ID: assignment.ID.String(),
		User: &auth.User{
			ID: userID,
		},
		Permission: &rbac.Permission{
			ID: permID,
		},
		IsGranted: assignment.IsGranted,
		CreatedAt: assignment.CreatedAt,
		CreatedBy: &auth.User{
			ID: createdByID,
		},
	}

	if assignment.ScopeType != "" && assignment.ScopeID != nil {
		graphqlAssignment.Scope = &rbac.PermissionScope{
			Type: assignment.ScopeType,
			ID:   assignment.ScopeID.String(),
		}
	}

	if assignment.ExpiresAt != nil {
		graphqlAssignment.ExpiresAt = assignment.ExpiresAt
	}

	return graphqlAssignment
}

// convertTimeToPtr converts time.Time to *time.Time if not zero
func convertTimeToPtr(t time.Time) *time.Time {
	if t.IsZero() {
		return nil
	}
	return &t
}

// convertStringToPtr converts string to *string if not empty
func convertStringToPtr(s string) *string {
	if s == "" {
		return nil
	}
	return &s
}

// convertUUIDToPtr converts uuid.UUID to *uuid.UUID if not nil
func convertUUIDToPtr(id uuid.UUID) *uuid.UUID {
	if id == uuid.Nil {
		return nil
	}
	return &id
}

// convertHierarchyNodesToGraphQL converts domain RoleHierarchyNode slice to GraphQL type
func convertHierarchyNodesToGraphQL(nodes []*rbacModels.RoleHierarchyNode) []*rbac.RoleHierarchyNode {
	if nodes == nil {
		return nil
	}

	graphqlNodes := make([]*rbac.RoleHierarchyNode, len(nodes))
	for i, node := range nodes {
		graphqlNodes[i] = &rbac.RoleHierarchyNode{
			Role:        convertRoleToGraphQL(node.Role),
			Level:       int32(node.Level),
			Permissions: node.Permissions,
		}

		// Recursively convert children
		if node.Children != nil && len(node.Children) > 0 {
			graphqlNodes[i].Children = convertHierarchyNodesToGraphQL(node.Children)
		}
	}

	return graphqlNodes
}

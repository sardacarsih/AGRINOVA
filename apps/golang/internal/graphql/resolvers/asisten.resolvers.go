package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"agrinovagraphql/server/internal/graphql/domain/asisten"
	"agrinovagraphql/server/internal/graphql/domain/auth"
	"agrinovagraphql/server/internal/graphql/domain/common"
	"agrinovagraphql/server/internal/graphql/domain/mandor"
	"agrinovagraphql/server/internal/graphql/domain/master"
	"agrinovagraphql/server/internal/middleware"
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/google/uuid"
	"gorm.io/gorm"
)

// ApproveHarvest is the resolver for the approveHarvest field.
func (r *mutationResolver) ApproveHarvest(ctx context.Context, id string, notes *string) (*asisten.ApproveHarvestResult, error) {
	// Get current user from context
	userID, err := r.requireAsistenUserID(ctx)
	if err != nil {
		return &asisten.ApproveHarvestResult{
			Success: false,
			Message: "Unauthorized: User not found in context",
			Errors:  []string{"Authentication required"},
		}, nil
	}

	if err := r.ensureAsistenCanAccessHarvest(ctx, userID, id); err != nil {
		return &asisten.ApproveHarvestResult{
			Success: false,
			Message: "Data tidak termasuk bawahan Anda",
			Errors:  []string{err.Error()},
		}, nil
	}

	// Approve via PanenResolver
	input := asisten.ApproveHarvestInput{
		ID:         id,
		ApprovedBy: userID,
	}

	record, err := r.PanenResolver.ApproveHarvestRecord(ctx, input)
	if err != nil {
		return &asisten.ApproveHarvestResult{
			Success: false,
			Message: fmt.Sprintf("Failed to approve harvest: %v", err),
			Errors:  []string{err.Error()},
		}, nil
	}
	r.notifyMandorHarvestApproved(ctx, record, userID)
	publishHarvestRecordApproved(record)

	return &asisten.ApproveHarvestResult{
		Success:       true,
		Message:       "Harvest record approved successfully",
		HarvestRecord: record,
	}, nil
}

// RejectHarvest is the resolver for the rejectHarvest field.
func (r *mutationResolver) RejectHarvest(ctx context.Context, id string, reason string) (*asisten.ApproveHarvestResult, error) {
	userID, err := r.requireAsistenUserID(ctx)
	if err != nil {
		return &asisten.ApproveHarvestResult{
			Success: false,
			Message: "Unauthorized: User not found in context",
			Errors:  []string{"Authentication required"},
		}, nil
	}

	if err := r.ensureAsistenCanAccessHarvest(ctx, userID, id); err != nil {
		return &asisten.ApproveHarvestResult{
			Success: false,
			Message: "Data tidak termasuk bawahan Anda",
			Errors:  []string{err.Error()},
		}, nil
	}

	// Reject via PanenResolver
	input := asisten.RejectHarvestInput{
		ID:             id,
		RejectedReason: reason,
	}

	record, err := r.PanenResolver.RejectHarvestRecord(ctx, input)
	if err != nil {
		return &asisten.ApproveHarvestResult{
			Success: false,
			Message: fmt.Sprintf("Failed to reject harvest: %v", err),
			Errors:  []string{err.Error()},
		}, nil
	}
	r.notifyMandorHarvestRejected(ctx, record, reason, userID)
	publishHarvestRecordRejected(record)

	return &asisten.ApproveHarvestResult{
		Success:       true,
		Message:       "Harvest record rejected successfully",
		HarvestRecord: record,
	}, nil
}

// BatchApproval is the resolver for the batchApproval field.
func (r *mutationResolver) BatchApproval(ctx context.Context, input asisten.BatchApprovalInput) (*asisten.BatchApprovalResult, error) {
	// Get current user from context
	userID := middleware.GetUserFromContext(ctx)
	if userID == "" {
		return &asisten.BatchApprovalResult{
			Success:        false,
			TotalProcessed: 0,
			SuccessCount:   0,
			FailedCount:    int32(len(input.Ids)),
			Message:        "Unauthorized: User not found in context",
		}, nil
	}

	var results []*asisten.BatchItemResult
	successCount := 0
	failedCount := 0

	for _, id := range input.Ids {
		var err error
		if input.Action == asisten.BatchApprovalActionApprove {
			approveInput := asisten.ApproveHarvestInput{
				ID:         id,
				ApprovedBy: userID,
			}
			var approvedRecord *mandor.HarvestRecord
			approvedRecord, err = r.PanenResolver.ApproveHarvestRecord(ctx, approveInput)
			if err == nil {
				r.notifyMandorHarvestApproved(ctx, approvedRecord, userID)
				publishHarvestRecordApproved(approvedRecord)
			}
		} else {
			reason := "Batch rejection"
			if input.RejectionReason != nil {
				reason = *input.RejectionReason
			}
			rejectInput := asisten.RejectHarvestInput{
				ID:             id,
				RejectedReason: reason,
			}
			var rejectedRecord *mandor.HarvestRecord
			rejectedRecord, err = r.PanenResolver.RejectHarvestRecord(ctx, rejectInput)
			if err == nil {
				r.notifyMandorHarvestRejected(ctx, rejectedRecord, reason, userID)
				publishHarvestRecordRejected(rejectedRecord)
			}
		}

		itemResult := &asisten.BatchItemResult{
			ID:      id,
			Success: err == nil,
		}
		if err != nil {
			errMsg := err.Error()
			itemResult.Error = &errMsg
			failedCount++
		} else {
			successCount++
		}
		results = append(results, itemResult)
	}

	return &asisten.BatchApprovalResult{
		Success:        failedCount == 0,
		TotalProcessed: int32(len(input.Ids)),
		SuccessCount:   int32(successCount),
		FailedCount:    int32(failedCount),
		Results:        results,
		Message:        fmt.Sprintf("Processed %d records: %d successful, %d failed", len(input.Ids), successCount, failedCount),
	}, nil
}

// RequestCorrection is the resolver for the requestCorrection field.
func (r *mutationResolver) RequestCorrection(ctx context.Context, id string, corrections []string) (*asisten.ApproveHarvestResult, error) {
	// For now, we'll treat correction request as a special rejection
	reason := "Corrections requested: " + fmt.Sprintf("%v", corrections)

	input := asisten.RejectHarvestInput{
		ID:             id,
		RejectedReason: reason,
	}

	record, err := r.PanenResolver.RejectHarvestRecord(ctx, input)
	if err != nil {
		return &asisten.ApproveHarvestResult{
			Success: false,
			Message: fmt.Sprintf("Failed to request correction: %v", err),
			Errors:  []string{err.Error()},
		}, nil
	}
	r.notifyMandorHarvestRejected(ctx, record, reason, "")
	publishHarvestRecordRejected(record)

	return &asisten.ApproveHarvestResult{
		Success:       true,
		Message:       "Correction requested successfully",
		HarvestRecord: record,
	}, nil
}

// AsistenDashboard is the resolver for the asistenDashboard field.
func (r *queryResolver) AsistenDashboard(ctx context.Context) (*asisten.AsistenDashboardData, error) {
	// Get current user from context
	userID, err := r.requireAsistenUserID(ctx)
	if err != nil {
		return nil, err
	}

	// Get user info
	var user auth.User
	if err := r.db.Where("id = ?", userID).First(&user).Error; err != nil {
		return nil, fmt.Errorf("failed to fetch user: %w", err)
	}

	// Get assigned divisions for this asisten only
	divisionIDs, err := r.getAsistenDivisionIDs(ctx, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch asisten division assignments: %w", err)
	}

	var divisions []*master.Division
	if len(divisionIDs) > 0 {
		if err := r.db.WithContext(ctx).
			Preload("Estate").
			Where("id IN ?", divisionIDs).
			Find(&divisions).Error; err != nil {
			return nil, fmt.Errorf("failed to fetch assigned divisions: %w", err)
		}
	}

	// Get dashboard stats
	stats, err := r.AsistenDashboardStats(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch dashboard stats: %w", err)
	}

	// Get pending items (top 10)
	pendingResponse, err := r.PendingApprovals(ctx, &asisten.ApprovalFilterInput{
		Status:   ptrHarvestStatus(mandor.HarvestStatusPending),
		PageSize: ptrInt32(10),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to fetch pending items: %w", err)
	}

	// Get today's summary
	todaySummary, err := r.AsistenTodaySummary(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch today summary: %w", err)
	}

	// Build quick actions
	quickActions := []*asisten.AsistenQuickAction{
		{
			ID:       "view_pending",
			Type:     asisten.AsistenActionTypeViewPending,
			Title:    "View Pending",
			Count:    &stats.PendingApprovals,
			IsUrgent: stats.PendingApprovals > 10,
		},
		{
			ID:       "batch_approve",
			Type:     asisten.AsistenActionTypeBatchApprove,
			Title:    "Batch Approve",
			IsUrgent: false,
		},
		{
			ID:       "view_history",
			Type:     asisten.AsistenActionTypeViewHistory,
			Title:    "View History",
			IsUrgent: false,
		},
	}

	return &asisten.AsistenDashboardData{
		User:         &user,
		Divisions:    divisions,
		Stats:        stats,
		PendingItems: pendingResponse.Items,
		TodaySummary: todaySummary,
		QuickActions: quickActions,
	}, nil
}

// AsistenDashboardStats is the resolver for the asistenDashboardStats field.
func (r *queryResolver) AsistenDashboardStats(ctx context.Context) (*asisten.AsistenDashboardStats, error) {
	userID, err := r.requireAsistenUserID(ctx)
	if err != nil {
		return nil, err
	}

	var pendingCount, approvedToday, rejectedToday int64
	var totalWeight float64

	today := time.Now().Truncate(24 * time.Hour)
	scopedHarvestQuery := func() *gorm.DB {
		return r.applyAsistenScopeToHarvestQuery(
			r.db.WithContext(ctx).Table("harvest_records"),
			userID,
		)
	}

	// Count pending approvals
	if err := scopedHarvestQuery().
		Where("harvest_records.status = ?", mandor.HarvestStatusPending).
		Count(&pendingCount).Error; err != nil {
		return nil, fmt.Errorf("failed to count pending approvals: %w", err)
	}

	// Count approved today
	if err := scopedHarvestQuery().
		Where("harvest_records.status = ? AND harvest_records.approved_at >= ?", mandor.HarvestStatusApproved, today).
		Count(&approvedToday).Error; err != nil {
		return nil, fmt.Errorf("failed to count approved approvals: %w", err)
	}

	// Count rejected today
	if err := scopedHarvestQuery().
		Where("harvest_records.status = ? AND harvest_records.updated_at >= ?", mandor.HarvestStatusRejected, today).
		Count(&rejectedToday).Error; err != nil {
		return nil, fmt.Errorf("failed to count rejected approvals: %w", err)
	}

	// Get today's production
	if err := scopedHarvestQuery().
		Where("harvest_records.tanggal >= ? AND harvest_records.status = ?", today, mandor.HarvestStatusApproved).
		Select("COALESCE(SUM(harvest_records.berat_tbs), 0)").
		Scan(&totalWeight).Error; err != nil {
		return nil, fmt.Errorf("failed to sum production: %w", err)
	}

	// Count assigned divisions and blocks in assigned divisions only.
	var totalDivisions, totalBlocks int64
	if err := r.db.WithContext(ctx).
		Table("user_division_assignments").
		Where("user_id = ? AND is_active = ?", userID, true).
		Distinct("division_id").
		Count(&totalDivisions).Error; err != nil {
		return nil, fmt.Errorf("failed to count assigned divisions: %w", err)
	}

	if err := r.db.WithContext(ctx).
		Table("blocks").
		Joins("JOIN user_division_assignments uda ON uda.division_id = blocks.division_id").
		Where("uda.user_id = ? AND uda.is_active = ?", userID, true).
		Distinct("blocks.id").
		Count(&totalBlocks).Error; err != nil {
		return nil, fmt.Errorf("failed to count blocks in assigned divisions: %w", err)
	}

	// Count direct mandor subordinates and active subordinate mandors today.
	var totalMandors, activeMandorsToday int64
	if err := r.db.WithContext(ctx).
		Model(&auth.User{}).
		Where("manager_id = ? AND role = ? AND is_active = ?", userID, auth.UserRoleMandor, true).
		Count(&totalMandors).Error; err != nil {
		return nil, fmt.Errorf("failed to count mandor subordinates: %w", err)
	}

	if err := scopedHarvestQuery().
		Where("tanggal >= ?", today).
		Distinct("mandor_id").
		Count(&activeMandorsToday).Error; err != nil {
		return nil, fmt.Errorf("failed to count active mandors: %w", err)
	}

	return &asisten.AsistenDashboardStats{
		TotalDivisions:     int32(totalDivisions),
		TotalBlocks:        int32(totalBlocks),
		PendingApprovals:   int32(pendingCount),
		ApprovedToday:      int32(approvedToday),
		RejectedToday:      int32(rejectedToday),
		AvgApprovalTime:    15.0, // Placeholder - would need to calculate from timestamps
		TotalMandors:       int32(totalMandors),
		ActiveMandorsToday: int32(activeMandorsToday),
		TodayProduction:    totalWeight / 1000, // Convert kg to tons
	}, nil
}

// AsistenTodaySummary is the resolver for the asistenTodaySummary field.
func (r *queryResolver) AsistenTodaySummary(ctx context.Context) (*asisten.AsistenTodaySummary, error) {
	userID, err := r.requireAsistenUserID(ctx)
	if err != nil {
		return nil, err
	}

	today := time.Now().Truncate(24 * time.Hour)

	var totalSubmissions, pending, approved, rejected int64
	var totalTbs int64
	var totalWeight float64
	scopedHarvestQuery := func() *gorm.DB {
		return r.applyAsistenScopeToHarvestQuery(
			r.db.WithContext(ctx).Table("harvest_records"),
			userID,
		)
	}

	// Count today's submissions by status
	if err := scopedHarvestQuery().
		Where("harvest_records.tanggal >= ?", today).
		Count(&totalSubmissions).Error; err != nil {
		return nil, fmt.Errorf("failed to count total submissions: %w", err)
	}

	if err := scopedHarvestQuery().
		Where("harvest_records.tanggal >= ? AND harvest_records.status = ?", today, mandor.HarvestStatusPending).
		Count(&pending).Error; err != nil {
		return nil, fmt.Errorf("failed to count pending submissions: %w", err)
	}

	if err := scopedHarvestQuery().
		Where("harvest_records.tanggal >= ? AND harvest_records.status = ?", today, mandor.HarvestStatusApproved).
		Count(&approved).Error; err != nil {
		return nil, fmt.Errorf("failed to count approved submissions: %w", err)
	}

	if err := scopedHarvestQuery().
		Where("harvest_records.tanggal >= ? AND harvest_records.status = ?", today, mandor.HarvestStatusRejected).
		Count(&rejected).Error; err != nil {
		return nil, fmt.Errorf("failed to count rejected submissions: %w", err)
	}

	// Get totals
	if err := scopedHarvestQuery().
		Where("harvest_records.tanggal >= ?", today).
		Select("COALESCE(SUM(harvest_records.jumlah_janjang), 0)").
		Scan(&totalTbs).Error; err != nil {
		return nil, fmt.Errorf("failed to sum total tbs: %w", err)
	}

	if err := scopedHarvestQuery().
		Where("harvest_records.tanggal >= ?", today).
		Select("COALESCE(SUM(harvest_records.berat_tbs), 0)").
		Scan(&totalWeight).Error; err != nil {
		return nil, fmt.Errorf("failed to sum total weight: %w", err)
	}

	// Count active workers (distinct mandors with submissions today)
	var activeWorkers int64
	if err := scopedHarvestQuery().
		Where("harvest_records.tanggal >= ?", today).
		Distinct("harvest_records.mandor_id").
		Count(&activeWorkers).Error; err != nil {
		return nil, fmt.Errorf("failed to count active workers: %w", err)
	}

	return &asisten.AsistenTodaySummary{
		TotalSubmissions: int32(totalSubmissions),
		Pending:          int32(pending),
		Approved:         int32(approved),
		Rejected:         int32(rejected),
		TotalTbs:         int32(totalTbs),
		TotalWeight:      totalWeight / 1000, // Convert kg to tons
		ActiveWorkers:    int32(activeWorkers),
		BusiestBlock:     nil, // Would need additional query
	}, nil
}

// PendingApprovals is the resolver for the pendingApprovals field.
func (r *queryResolver) PendingApprovals(ctx context.Context, filter *asisten.ApprovalFilterInput) (*asisten.ApprovalListResponse, error) {
	userID, err := r.requireAsistenUserID(ctx)
	if err != nil {
		return nil, err
	}

	// Base query must only include records from mandor subordinates of this asisten.
	query := r.applyAsistenScopeToHarvestQuery(
		r.db.WithContext(ctx).Table("harvest_records"),
		userID,
	)

	// Default to pending status if not specified
	status := mandor.HarvestStatusPending
	if filter != nil && filter.Status != nil {
		status = *filter.Status
	}
	query = query.Where("harvest_records.status = ?", status)

	// Apply filters
	if filter != nil {
		if filter.DivisionID != nil {
			query = query.Joins("JOIN blocks ON blocks.id = harvest_records.block_id").
				Where("blocks.division_id = ?", *filter.DivisionID)
		}
		if filter.BlockID != nil {
			query = query.Where("harvest_records.block_id = ?", *filter.BlockID)
		}
		if filter.MandorID != nil {
			query = query.Where("harvest_records.mandor_id = ?", *filter.MandorID)
		}
		if filter.DateFrom != nil {
			query = query.Where("harvest_records.tanggal >= ?", *filter.DateFrom)
		}
		if filter.DateTo != nil {
			query = query.Where("harvest_records.tanggal <= ?", *filter.DateTo)
		}
		if filter.Search != nil && *filter.Search != "" {
			searchTerm := "%" + *filter.Search + "%"
			query = query.Where("COALESCE(harvest_records.nik, '') ILIKE ?", searchTerm)
		}
	}

	// Count total
	var totalCount int64
	query.Count(&totalCount)

	// Apply pagination
	page := int32(1)
	pageSize := int32(20)
	if filter != nil {
		if filter.Page != nil && *filter.Page > 0 {
			page = *filter.Page
		}
		if filter.PageSize != nil && *filter.PageSize > 0 {
			pageSize = *filter.PageSize
		}
	}
	offset := (page - 1) * pageSize
	query = query.Offset(int(offset)).Limit(int(pageSize))

	// Apply sorting
	orderBy := "harvest_records.created_at DESC"
	if filter != nil && filter.SortBy != nil {
		switch *filter.SortBy {
		case asisten.ApprovalSortFieldSubmittedAt:
			orderBy = "harvest_records.created_at"
		case asisten.ApprovalSortFieldHarvestDate:
			orderBy = "harvest_records.tanggal"
		case asisten.ApprovalSortFieldWeight:
			orderBy = "harvest_records.berat_tbs"
		case asisten.ApprovalSortFieldTbsCount:
			orderBy = "harvest_records.jumlah_janjang"
		}
		if filter.SortDirection != nil && *filter.SortDirection == common.SortDirectionAsc {
			orderBy += " ASC"
		} else {
			orderBy += " DESC"
		}
	}
	query = query.Order(orderBy)

	// Execute query
	query = query.Select(r.asistenApprovalHarvestSelectColumns())
	var records []*mandor.HarvestRecord
	if err := query.Find(&records).Error; err != nil {
		return nil, fmt.Errorf("failed to fetch pending approvals: %w", err)
	}

	// Convert to ApprovalItem with manual relationship loading
	items := make([]*asisten.ApprovalItem, 0, len(records))
	for _, record := range records {
		item := r.convertHarvestToApprovalItemWithLoading(ctx, record)
		items = append(items, item)
	}

	totalPages := (int32(totalCount) + pageSize - 1) / pageSize

	return &asisten.ApprovalListResponse{
		Items:      items,
		TotalCount: int32(totalCount),
		HasMore:    page < totalPages,
		PageInfo: &asisten.ApprovalPageInfo{
			CurrentPage: page,
			TotalPages:  totalPages,
			PageSize:    pageSize,
		},
	}, nil
}

// ApprovalItem is the resolver for the approvalItem field.
func (r *queryResolver) ApprovalItem(ctx context.Context, id string) (*asisten.ApprovalItem, error) {
	userID, err := r.requireAsistenUserID(ctx)
	if err != nil {
		return nil, err
	}

	var record mandor.HarvestRecord
	err = r.applyAsistenScopeToHarvestQuery(
		r.db.WithContext(ctx).Table("harvest_records"),
		userID,
	).Select(r.asistenApprovalHarvestSelectColumns()).
		Where("harvest_records.id = ?", id).
		First(&record).Error

	if err != nil {
		return nil, fmt.Errorf("approval item not found: %w", err)
	}

	return r.convertHarvestToApprovalItemWithLoading(ctx, &record), nil
}

// ApprovalHistory is the resolver for the approvalHistory field.
func (r *queryResolver) ApprovalHistory(ctx context.Context, filter *asisten.ApprovalFilterInput) (*asisten.ApprovalListResponse, error) {
	userID, err := r.requireAsistenUserID(ctx)
	if err != nil {
		return nil, err
	}

	// Similar to PendingApprovals but for completed (approved/rejected) records
	query := r.applyAsistenScopeToHarvestQuery(
		r.db.WithContext(ctx).Table("harvest_records"),
		userID,
	).
		Where("harvest_records.status IN ?", []mandor.HarvestStatus{
			mandor.HarvestStatusApproved,
			mandor.HarvestStatusRejected,
		})

	// Apply same filters as PendingApprovals
	if filter != nil {
		if filter.Status != nil {
			query = query.Where("harvest_records.status = ?", *filter.Status)
		}
		if filter.DivisionID != nil {
			query = query.Joins("JOIN blocks ON blocks.id = harvest_records.block_id").
				Where("blocks.division_id = ?", *filter.DivisionID)
		}
		if filter.DateFrom != nil {
			query = query.Where("harvest_records.tanggal >= ?", *filter.DateFrom)
		}
		if filter.DateTo != nil {
			query = query.Where("harvest_records.tanggal <= ?", *filter.DateTo)
		}
	}

	var totalCount int64
	query.Count(&totalCount)

	page := int32(1)
	pageSize := int32(20)
	if filter != nil {
		if filter.Page != nil && *filter.Page > 0 {
			page = *filter.Page
		}
		if filter.PageSize != nil && *filter.PageSize > 0 {
			pageSize = *filter.PageSize
		}
	}

	query = query.Offset(int((page - 1) * pageSize)).Limit(int(pageSize)).Order("harvest_records.updated_at DESC")

	query = query.Select(r.asistenApprovalHarvestSelectColumns())
	var records []*mandor.HarvestRecord
	if err := query.Find(&records).Error; err != nil {
		return nil, fmt.Errorf("failed to fetch approval history: %w", err)
	}

	items := make([]*asisten.ApprovalItem, 0, len(records))
	for _, record := range records {
		items = append(items, r.convertHarvestToApprovalItemWithLoading(ctx, record))
	}

	totalPages := (int32(totalCount) + pageSize - 1) / pageSize

	return &asisten.ApprovalListResponse{
		Items:      items,
		TotalCount: int32(totalCount),
		HasMore:    page < totalPages,
		PageInfo: &asisten.ApprovalPageInfo{
			CurrentPage: page,
			TotalPages:  totalPages,
			PageSize:    pageSize,
		},
	}, nil
}

// ApprovalStats is the resolver for the approvalStats field.
func (r *queryResolver) ApprovalStats(ctx context.Context, dateFrom *time.Time, dateTo *time.Time) (*asisten.ApprovalStatsData, error) {
	userID, err := r.requireAsistenUserID(ctx)
	if err != nil {
		return nil, err
	}

	scopedHarvestQuery := func() *gorm.DB {
		return r.applyAsistenScopeToHarvestQuery(
			r.db.WithContext(ctx).Table("harvest_records"),
			userID,
		)
	}
	query := scopedHarvestQuery()

	if dateFrom != nil {
		query = query.Where("harvest_records.tanggal >= ?", *dateFrom)
	}
	if dateTo != nil {
		query = query.Where("harvest_records.tanggal <= ?", *dateTo)
	}

	var totalSubmissions, totalApproved, totalRejected int64

	if err := query.Count(&totalSubmissions).Error; err != nil {
		return nil, fmt.Errorf("failed to count total submissions: %w", err)
	}

	if err := scopedHarvestQuery().
		Where("harvest_records.status = ?", mandor.HarvestStatusApproved).
		Count(&totalApproved).Error; err != nil {
		return nil, fmt.Errorf("failed to count total approved: %w", err)
	}

	if err := scopedHarvestQuery().
		Where("harvest_records.status = ?", mandor.HarvestStatusRejected).
		Count(&totalRejected).Error; err != nil {
		return nil, fmt.Errorf("failed to count total rejected: %w", err)
	}

	approvalRate := float64(0)
	if totalSubmissions > 0 {
		approvalRate = float64(totalApproved) / float64(totalSubmissions) * 100
	}

	return &asisten.ApprovalStatsData{
		TotalSubmissions: int32(totalSubmissions),
		TotalApproved:    int32(totalApproved),
		TotalRejected:    int32(totalRejected),
		ApprovalRate:     approvalRate,
		AvgApprovalTime:  15.0,  // Placeholder
		FastestApproval:  5.0,   // Placeholder
		SlowestApproval:  120.0, // Placeholder
		DailyStats:       []*asisten.DailyApprovalStats{},
	}, nil
}

// AsistenMonitoring is the resolver for the asistenMonitoring field.
func (r *queryResolver) AsistenMonitoring(ctx context.Context) (*asisten.AsistenMonitoringData, error) {
	now := time.Now()

	return &asisten.AsistenMonitoringData{
		OverallStatus:     common.MonitorStatusNormal,
		DivisionSummaries: []*asisten.AsistenDivisionSummary{},
		BlockActivities:   []*asisten.BlockActivity{},
		MandorStatuses:    []*mandor.MandorStatus{},
		RealtimeStats: &asisten.AsistenRealtimeStats{
			TotalSubmissionsToday: 0,
			PendingCount:          0,
			ActiveMandors:         0,
			ActiveBlocks:          0,
			TotalTbsToday:         0,
			TotalWeightToday:      0,
			AvgTbsPerSubmission:   0,
			ProductivityRate:      0,
		},
		ActivityTimeline: []*asisten.ActivityTimelineItem{},
		LastUpdated:      now,
	}, nil
}

// DivisionMonitoring is the resolver for the divisionMonitoring field.
func (r *queryResolver) DivisionMonitoring(ctx context.Context, divisionID string) (*asisten.AsistenDivisionSummary, error) {
	var division master.Division
	if err := r.db.Where("id = ?", divisionID).First(&division).Error; err != nil {
		return nil, fmt.Errorf("division not found: %w", err)
	}

	return &asisten.AsistenDivisionSummary{
		DivisionID:       division.ID,
		DivisionName:     division.Name,
		DivisionCode:     division.Code,
		Status:           common.MonitorStatusNormal,
		ActiveBlocks:     0,
		TotalBlocks:      0,
		ActiveMandors:    0,
		TotalMandors:     0,
		TodayProduction:  0,
		DailyTarget:      0,
		Progress:         0,
		PendingApprovals: 0,
		LastActivity:     nil,
	}, nil
}

// BlockActivities is the resolver for the blockActivities field.
func (r *queryResolver) BlockActivities(ctx context.Context, divisionID *string) ([]*asisten.BlockActivity, error) {
	return []*asisten.BlockActivity{}, nil
}

// MandorStatuses is the resolver for the mandorStatuses field.
func (r *queryResolver) MandorStatuses(ctx context.Context, divisionID *string) ([]*mandor.MandorStatus, error) {
	return []*mandor.MandorStatus{}, nil
}

// ActivityTimeline is the resolver for the activityTimeline field.
func (r *queryResolver) ActivityTimeline(ctx context.Context, divisionID *string, limit *int32, since *time.Time) ([]*asisten.ActivityTimelineItem, error) {
	return []*asisten.ActivityTimelineItem{}, nil
}

// NewHarvestSubmission is the resolver for the newHarvestSubmission field.
func (r *subscriptionResolver) NewHarvestSubmission(ctx context.Context, divisionID *string) (<-chan *asisten.ApprovalItem, error) {
	panic(fmt.Errorf("not implemented: NewHarvestSubmission - newHarvestSubmission"))
}

// AsistenMonitoringUpdate is the resolver for the asistenMonitoringUpdate field.
func (r *subscriptionResolver) AsistenMonitoringUpdate(ctx context.Context) (<-chan *asisten.AsistenMonitoringData, error) {
	panic(fmt.Errorf("not implemented: AsistenMonitoringUpdate - asistenMonitoringUpdate"))
}

// MandorStatusChange is the resolver for the mandorStatusChange field.
func (r *subscriptionResolver) MandorStatusChange(ctx context.Context, divisionID *string) (<-chan *mandor.MandorStatus, error) {
	panic(fmt.Errorf("not implemented: MandorStatusChange - mandorStatusChange"))
}

// BlockActivityUpdate is the resolver for the blockActivityUpdate field.
func (r *subscriptionResolver) BlockActivityUpdate(ctx context.Context, divisionID *string) (<-chan *asisten.BlockActivity, error) {
	panic(fmt.Errorf("not implemented: BlockActivityUpdate - blockActivityUpdate"))
}

// Helper functions

// convertHarvestToApprovalItemWithLoading manually loads related data to avoid GORM deep preload issues
func (r *queryResolver) convertHarvestToApprovalItemWithLoading(ctx context.Context, record *mandor.HarvestRecord) *asisten.ApprovalItem {
	photoUrls := normalizeHarvestPhotoURLs(record.PhotoURL)

	item := &asisten.ApprovalItem{
		ID:               record.ID,
		HarvestDate:      record.Tanggal,
		EmployeeCount:    1, // Would need to parse karyawan field
		Employees:        r.resolveHarvestEmployeeLabel(record),
		TbsCount:         record.JumlahJanjang,
		Weight:           record.BeratTbs,
		SubmittedAt:      record.CreatedAt,
		ElapsedTime:      calculateElapsedTime(record.CreatedAt),
		Status:           record.Status,
		HasPhoto:         len(photoUrls) > 0,
		PhotoUrls:        photoUrls,
		Coordinates:      nil,
		Notes:            record.RejectedReason,
		Priority:         calculatePriority(record.CreatedAt),
		ValidationStatus: asisten.ValidationStatusValid,
		ValidationIssues: nil,
	}

	// Manually load Mandor (User)
	if record.MandorID != "" {
		var mandor auth.User
		if err := r.db.Where("id = ?", record.MandorID).First(&mandor).Error; err == nil {
			item.Mandor = &mandor
		}
	}

	// Manually load Block and Division
	if record.BlockID != "" {
		var block master.Block
		if err := r.db.Where("id = ?", record.BlockID).First(&block).Error; err == nil {
			item.Block = &block

			// Load Division for the block
			if block.DivisionID != "" {
				var division master.Division
				if err := r.db.Where("id = ?", block.DivisionID).First(&division).Error; err == nil {
					item.Division = &division
					// Also set division on block for completeness
					item.Block.Division = &division
				}
			}
		}
	}

	return item
}

func (r *queryResolver) resolveHarvestEmployeeLabel(record *mandor.HarvestRecord) string {
	if record == nil {
		return ""
	}

	if name := r.lookupEmployeeNameByID(record.KaryawanID); name != "" {
		return name
	}

	if name := r.lookupEmployeeNameByNIK(record.Nik, record.CompanyID); name != "" {
		return name
	}

	if record.Nik != nil {
		nik := strings.TrimSpace(*record.Nik)
		if nik != "" {
			return nik
		}
	}
	if record.KaryawanID != nil {
		karyawanID := strings.TrimSpace(*record.KaryawanID)
		if karyawanID != "" {
			return karyawanID
		}
	}

	return ""
}

func (r *Resolver) asistenApprovalHarvestSelectColumns() []string {
	// Use explicit columns so resolver stays compatible with databases that
	// have not yet added optional fields like harvest_records.device_id.
	return []string{
		"harvest_records.id",
		"harvest_records.tanggal",
		"harvest_records.mandor_id",
		"harvest_records.company_id",
		"harvest_records.block_id",
		"harvest_records.nik",
		"harvest_records.karyawan_id",
		"harvest_records.berat_tbs",
		"harvest_records.jumlah_janjang",
		"harvest_records.status",
		"harvest_records.rejected_reason",
		"harvest_records.photo_url",
		"harvest_records.created_at",
	}
}

func normalizeHarvestPhotoURLs(photoURL *string) []string {
	if photoURL == nil {
		return nil
	}

	trimmed := strings.TrimSpace(*photoURL)
	if trimmed == "" {
		return nil
	}

	if strings.HasPrefix(trimmed, "http://") || strings.HasPrefix(trimmed, "https://") {
		return []string{trimmed}
	}

	if strings.HasPrefix(trimmed, "uploads/") {
		return []string{"/" + trimmed}
	}

	return []string{trimmed}
}

func (r *queryResolver) lookupEmployeeNameFromRaw(raw string, companyID *string) string {
	candidate := strings.TrimSpace(raw)
	if candidate == "" {
		return ""
	}

	// If value is UUID-like, try lookup by employee ID first.
	if _, err := uuid.Parse(candidate); err == nil {
		id := candidate
		if name := r.lookupEmployeeNameByID(&id); name != "" {
			return name
		}
	}

	// Try lookup by NIK/employee code.
	nik := candidate
	return r.lookupEmployeeNameByNIK(&nik, companyID)
}

func (r *queryResolver) lookupEmployeeNameByID(employeeID *string) string {
	if employeeID == nil {
		return ""
	}

	id := strings.TrimSpace(*employeeID)
	if id == "" {
		return ""
	}

	var name string
	tx := r.db.Table("employees").
		Select("name").
		Where("id = ?", id).
		Limit(1).
		Scan(&name)

	if tx.Error != nil || tx.RowsAffected == 0 {
		return ""
	}

	return strings.TrimSpace(name)
}

func (r *queryResolver) lookupEmployeeNameByNIK(nik *string, companyID *string) string {
	if nik == nil {
		return ""
	}

	nikValue := strings.TrimSpace(*nik)
	if nikValue == "" {
		return ""
	}

	query := r.db.Table("employees").
		Select("name").
		Where("nik = ?", nikValue)

	if companyID != nil {
		companyValue := strings.TrimSpace(*companyID)
		if companyValue != "" {
			query = query.Where("company_id = ?", companyValue)
		}
	}

	var name string
	tx := query.Limit(1).Scan(&name)
	if tx.Error != nil || tx.RowsAffected == 0 {
		return ""
	}

	return strings.TrimSpace(name)
}

func calculateElapsedTime(submittedAt time.Time) string {
	elapsed := time.Since(submittedAt)
	if elapsed < time.Hour {
		return fmt.Sprintf("%d menit", int(elapsed.Minutes()))
	} else if elapsed < 24*time.Hour {
		return fmt.Sprintf("%d jam", int(elapsed.Hours()))
	}
	return fmt.Sprintf("%d hari", int(elapsed.Hours()/24))
}

func calculatePriority(submittedAt time.Time) asisten.ApprovalPriority {
	elapsed := time.Since(submittedAt)
	if elapsed > 4*time.Hour {
		return asisten.ApprovalPriorityUrgent
	} else if elapsed > 2*time.Hour {
		return asisten.ApprovalPriorityHigh
	}
	return asisten.ApprovalPriorityNormal
}

func ptrHarvestStatus(s mandor.HarvestStatus) *mandor.HarvestStatus {
	return &s
}

func ptrInt32(i int32) *int32 {
	return &i
}

func (r *Resolver) requireAsistenUserID(ctx context.Context) (string, error) {
	userID := middleware.GetUserFromContext(ctx)
	if userID == "" {
		return "", fmt.Errorf("unauthorized: user not found in context")
	}
	return userID, nil
}

func (r *Resolver) applyAsistenScopeToHarvestQuery(query *gorm.DB, asistenUserID string) *gorm.DB {
	return query.
		Joins("JOIN users AS mandors ON mandors.id = harvest_records.mandor_id").
		Where("mandors.manager_id = ?", asistenUserID).
		Where("mandors.is_active = ?", true).
		Where("mandors.deleted_at IS NULL")
}

func (r *Resolver) ensureAsistenCanAccessHarvest(ctx context.Context, asistenUserID, harvestID string) error {
	var count int64
	err := r.applyAsistenScopeToHarvestQuery(
		r.db.WithContext(ctx).Table("harvest_records"),
		asistenUserID,
	).
		Where("harvest_records.id = ?", harvestID).
		Count(&count).Error
	if err != nil {
		return fmt.Errorf("failed to validate harvest ownership: %w", err)
	}
	if count == 0 {
		return fmt.Errorf("harvest not found for asisten subordinate scope")
	}
	return nil
}

func (r *Resolver) getAsistenDivisionIDs(ctx context.Context, asistenUserID string) ([]string, error) {
	var divisionIDs []string
	err := r.db.WithContext(ctx).
		Table("user_division_assignments").
		Where("user_id = ? AND is_active = ?", asistenUserID, true).
		Pluck("division_id", &divisionIDs).Error
	if err != nil {
		return nil, err
	}
	return divisionIDs, nil
}

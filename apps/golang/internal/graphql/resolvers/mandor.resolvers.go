package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.83

import (
	"agrinovagraphql/server/internal/graphql/domain/asisten"
	"agrinovagraphql/server/internal/graphql/domain/auth"
	"agrinovagraphql/server/internal/graphql/domain/common"
	"agrinovagraphql/server/internal/graphql/domain/mandor"
	"agrinovagraphql/server/internal/graphql/domain/master"
	"agrinovagraphql/server/internal/middleware"
	notificationModels "agrinovagraphql/server/internal/notifications/models"
	notificationServices "agrinovagraphql/server/internal/notifications/services"

	panenModels "agrinovagraphql/server/internal/panen/models"
	panenResolvers "agrinovagraphql/server/internal/panen/resolvers"
	"context"
	"encoding/base64"
	"errors"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"regexp"
	"strings"
	"time"

	"github.com/google/uuid"
	"gorm.io/gorm"
)

// CreateMandorHarvest is the resolver for the createMandorHarvest field.
func (r *mutationResolver) CreateMandorHarvest(ctx context.Context, input mandor.CreateMandorHarvestInput) (*mandor.MandorHarvestResult, error) {
	// 1. Get MandorID from context (authenticated user)
	userID, ok := ctx.Value("user_id").(string)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	// 2. Check for existing record by LocalID (Idempotency)
	// input.LocalID is String! in schema, so it is a value, not pointer
	if input.LocalID != "" {
		existing, err := r.PanenResolver.GetByLocalID(ctx, input.LocalID, userID)
		if err == nil && existing != nil {
			// Already exists, return successful result with existing data
			return &mandor.MandorHarvestResult{
				Success:       true,
				Message:       "Record already exists",
				HarvestRecord: convertToMandorHarvestRecord((*mandor.HarvestRecord)(existing)),
				ServerID:      &existing.ID,
			}, nil
		}
	}

	// 3. Handle optional fields
	// BeratTbs is *float64 in CreateMandorHarvestInput (optional)
	var beratTbs float64
	if input.BeratTbs != nil {
		beratTbs = *input.BeratTbs
	}

	// Prepare input for creation
	// CreateHarvestRecordInput.LocalID expects *string
	// Convert string value to pointer
	var localIDPtr *string
	if input.LocalID != "" {
		localID := input.LocalID
		localIDPtr = &localID
	}

	createInput := mandor.CreateHarvestRecordInput{
		LocalID:       localIDPtr,
		DeviceID:      stringPointerIfNotEmpty(input.DeviceID),
		Tanggal:       input.Tanggal,
		MandorID:      userID, // Use authenticated user ID
		BlockID:       input.BlockID,
		Karyawan:      input.Karyawan,
		JumlahJanjang: int32(input.JumlahJanjang),
		BeratTbs:      beratTbs,
	}

	// Create new record
	newRecord, err := r.PanenResolver.CreateHarvestRecord(ctx, createInput)
	if err != nil {
		return &mandor.MandorHarvestResult{
			Success: false,
			Message: err.Error(),
			Errors:  []string{err.Error()},
		}, nil
	}
	r.notifyAsistenHarvestCreated(ctx, newRecord)
	publishHarvestRecordCreated((*mandor.HarvestRecord)(newRecord))

	return &mandor.MandorHarvestResult{
		Success:       true,
		Message:       "Harvest record created successfully",
		HarvestRecord: convertToMandorHarvestRecord((*mandor.HarvestRecord)(newRecord)),
		ServerID:      &newRecord.ID,
	}, nil
}

// UpdateMandorHarvest is the resolver for the updateMandorHarvest field.
func (r *mutationResolver) UpdateMandorHarvest(ctx context.Context, input mandor.UpdateMandorHarvestInput) (*mandor.MandorHarvestResult, error) {
	panic(fmt.Errorf("not implemented: UpdateMandorHarvest - updateMandorHarvest"))
}

// DeleteMandorHarvest is the resolver for the deleteMandorHarvest field.
func (r *mutationResolver) DeleteMandorHarvest(ctx context.Context, id string, deviceID string) (*mandor.MandorHarvestResult, error) {
	panic(fmt.Errorf("not implemented: DeleteMandorHarvest - deleteMandorHarvest"))
}

// SyncMandorHarvests is the resolver for the syncMandorHarvests field.
func (r *mutationResolver) SyncMandorHarvests(ctx context.Context, input mandor.MandorSyncInput) (*mandor.MandorSyncResult, error) {
	panic(fmt.Errorf("not implemented: SyncMandorHarvests - syncMandorHarvests"))
}

// SyncMandorPhotos is the resolver for the syncMandorPhotos field.
func (r *mutationResolver) SyncMandorPhotos(ctx context.Context, input mandor.MandorPhotoSyncInput) (*mandor.MandorPhotoSyncResult, error) {
	panic(fmt.Errorf("not implemented: SyncMandorPhotos - syncMandorPhotos"))
}

// MarkMandorSyncCompleted is the resolver for the markMandorSyncCompleted field.
func (r *mutationResolver) MarkMandorSyncCompleted(ctx context.Context, deviceID string, transactionID string) (bool, error) {
	panic(fmt.Errorf("not implemented: MarkMandorSyncCompleted - markMandorSyncCompleted"))
}

// CreateHarvestRecord is the resolver for the createHarvestRecord field.
func (r *mutationResolver) CreateHarvestRecord(ctx context.Context, input mandor.CreateHarvestRecordInput) (*mandor.HarvestRecord, error) {
	// Convert internal models.HarvestRecord to mandor.HarvestRecord
	harvestModel, err := r.PanenResolver.CreateHarvestRecord(ctx, input)
	if err != nil {
		return nil, err
	}
	r.notifyAsistenHarvestCreated(ctx, harvestModel)
	publishHarvestRecordCreated((*mandor.HarvestRecord)(harvestModel))

	// Convert to GraphQL generated type
	return (*mandor.HarvestRecord)(harvestModel), nil
}

// UpdateHarvestRecord is the resolver for the updateHarvestRecord field.
func (r *mutationResolver) UpdateHarvestRecord(ctx context.Context, input mandor.UpdateHarvestRecordInput) (*mandor.HarvestRecord, error) {
	harvestModel, err := r.PanenResolver.UpdateHarvestRecord(ctx, input)
	if err != nil {
		return nil, err
	}

	return (*mandor.HarvestRecord)(harvestModel), nil
}

// ApproveHarvestRecord is the resolver for the approveHarvestRecord field.
func (r *mutationResolver) ApproveHarvestRecord(ctx context.Context, input asisten.ApproveHarvestInput) (*mandor.HarvestRecord, error) {
	currentUserID := strings.TrimSpace(middleware.GetCurrentUserID(ctx))
	if currentUserID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	currentRole := middleware.GetUserRoleFromContext(ctx)
	if currentRole == auth.UserRoleManager {
		if err := r.ensureManagerCanAccessHarvest(ctx, currentUserID, input.ID); err != nil {
			return nil, err
		}
	}

	effectiveInput := input
	effectiveInput.ApprovedBy = currentUserID

	harvestModel, err := r.PanenResolver.ApproveHarvestRecord(ctx, effectiveInput)
	if err != nil {
		return nil, err
	}
	r.notifyMandorHarvestApproved(ctx, harvestModel, currentUserID)
	publishHarvestRecordApproved((*mandor.HarvestRecord)(harvestModel))

	return (*mandor.HarvestRecord)(harvestModel), nil
}

// RejectHarvestRecord is the resolver for the rejectHarvestRecord field.
func (r *mutationResolver) RejectHarvestRecord(ctx context.Context, input asisten.RejectHarvestInput) (*mandor.HarvestRecord, error) {
	currentUserID := strings.TrimSpace(middleware.GetCurrentUserID(ctx))
	if currentUserID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	currentRole := middleware.GetUserRoleFromContext(ctx)
	if currentRole == auth.UserRoleManager {
		if err := r.ensureManagerCanAccessHarvest(ctx, currentUserID, input.ID); err != nil {
			return nil, err
		}
	}

	harvestModel, err := r.PanenResolver.RejectHarvestRecord(ctx, input)
	if err != nil {
		return nil, err
	}
	r.notifyMandorHarvestRejected(ctx, harvestModel, input.RejectedReason, currentUserID)
	publishHarvestRecordRejected((*mandor.HarvestRecord)(harvestModel))

	return (*mandor.HarvestRecord)(harvestModel), nil
}

// DeleteHarvestRecord is the resolver for the deleteHarvestRecord field.
func (r *mutationResolver) DeleteHarvestRecord(ctx context.Context, id string) (bool, error) {
	return r.PanenResolver.DeleteHarvestRecord(ctx, id)
}

// SyncHarvestRecords is the resolver for the syncHarvestRecords field.
// Supports both CREATE (new records) and UPDATE (existing records with serverId)
func (r *mutationResolver) SyncHarvestRecords(ctx context.Context, input mandor.HarvestSyncInput) (*mandor.MandorSyncResult, error) {
	authUserID := strings.TrimSpace(middleware.GetCurrentUserID(ctx))
	if authUserID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	successCount := 0
	failureCount := 0
	conflictsDetected := 0
	createdCount := 0
	updatedCount := 0
	var syncResults []*mandor.MandorSyncItemResult

	stringValue := func(value *string) string {
		if value == nil {
			return ""
		}
		return strings.TrimSpace(*value)
	}
	photoSummary := func(value *string) string {
		raw := strings.TrimSpace(stringValue(value))
		if raw == "" {
			return ""
		}
		if strings.HasPrefix(raw, "data:image/") {
			return fmt.Sprintf("data-uri(%d chars)", len(raw))
		}
		if len(raw) > 120 {
			return raw[:120] + "..."
		}
		return raw
	}

	fmt.Printf(
		"ðŸ“¥ [SyncHarvestRecords] deviceId=%s clientTimestamp=%s records=%d\n",
		strings.TrimSpace(input.DeviceID),
		input.ClientTimestamp.Format(time.RFC3339),
		len(input.Records),
	)
	for idx, recordInput := range input.Records {
		if recordInput == nil {
			fmt.Printf("âš ï¸ [SyncHarvestRecords][%d] record is nil\n", idx)
			continue
		}

		fmt.Printf(
			"ðŸ“¦ [SyncHarvestRecords][%d] localId=%s serverId=%s mandorId=%s blockId=%s karyawanId=%s nik=%q jumlahJanjang=%d beratTbs=%.2f status=%s companyId=%s estateId=%s divisionId=%s employeeDivisionId=%s employeeDivisionName=%s photo=%s\n",
			idx,
			strings.TrimSpace(recordInput.LocalID),
			stringValue(recordInput.ServerID),
			strings.TrimSpace(recordInput.MandorID),
			strings.TrimSpace(recordInput.BlockID),
			recordInput.KaryawanID,
			strings.TrimSpace(recordInput.Nik),
			recordInput.JumlahJanjang,
			recordInput.BeratTbs,
			stringValue(recordInput.Status),
			stringValue(recordInput.CompanyID),
			stringValue(recordInput.EstateID),
			stringValue(recordInput.DivisionID),
			stringValue(recordInput.EmployeeDivisionID),
			stringValue(recordInput.EmployeeDivisionName),
			photoSummary(recordInput.PhotoURL),
		)
	}

	for _, recordInput := range input.Records {
		if recordInput == nil {
			failureCount++
			errMsg := "invalid sync record: payload item is null"
			syncResults = append(syncResults, &mandor.MandorSyncItemResult{
				Success: false,
				Status:  common.SyncItemStatusRejected,
				Error:   &errMsg,
			})
			continue
		}

		var err error
		var record *mandor.HarvestRecord
		var createdModel *panenModels.HarvestRecord
		recordCreated := false
		recordUpdated := false
		recordConflict := false
		conflictResolutionFailed := false
		effectiveMandorID := authUserID
		effectiveDeviceID := strings.TrimSpace(input.DeviceID)
		effectiveKaryawanID := normalizeSyncKaryawanID(recordInput.KaryawanID)
		effectiveEmployeeDivisionID := normalizeSyncOptionalUUID(recordInput.EmployeeDivisionID)
		effectiveEmployeeDivisionName := normalizeSyncOptionalText(recordInput.EmployeeDivisionName)
		if effectiveKaryawanID == nil {
			errMsg := "invalid karyawanId: must be a UUID"
			syncResults = append(syncResults, &mandor.MandorSyncItemResult{
				LocalID:  recordInput.LocalID,
				ServerID: recordInput.ServerID,
				Success:  false,
				Status:   common.SyncItemStatusRejected,
				Error:    &errMsg,
			})
			failureCount++
			continue
		}

		effectiveNik := normalizeSyncNik(recordInput.Nik)
		if effectiveNik == nil {
			errMsg := "invalid nik: must not be empty"
			syncResults = append(syncResults, &mandor.MandorSyncItemResult{
				LocalID:  recordInput.LocalID,
				ServerID: recordInput.ServerID,
				Success:  false,
				Status:   common.SyncItemStatusRejected,
				Error:    &errMsg,
			})
			failureCount++
			continue
		}

		err = r.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
			scopedPanenResolver := r.PanenResolver.WithDB(tx)
			isUpdate := false

			// Determine if this is an UPDATE or CREATE based on ServerID presence.
			if recordInput.ServerID != nil && *recordInput.ServerID != "" {
				isUpdate = true
				existing, findErr := scopedPanenResolver.HarvestRecord(ctx, *recordInput.ServerID)
				if findErr != nil || existing == nil {
					// Server record not found - fall back to create path.
					isUpdate = false
				} else {
					if strings.TrimSpace(existing.MandorID) != effectiveMandorID {
						return fmt.Errorf("access denied: cannot sync another mandor's harvest record")
					}

					isConflict, conflictErr := r.checkAndResolveConflict(
						ctx,
						(*panenModels.HarvestRecord)(existing),
						recordInput,
						effectiveDeviceID,
						effectiveKaryawanID,
						effectiveNik,
					)
					if conflictErr != nil {
						conflictResolutionFailed = true
						return fmt.Errorf("conflict resolution failed: %w", conflictErr)
					}

					if isConflict {
						recordConflict = true
						// Server wins - return existing record without write.
						record = existing
						return nil
					}

					// No conflict - allow updates for:
					// 1) normal draft update (PENDING -> PENDING)
					// 2) correction flow (REJECTED -> PENDING)
					existingStatus := strings.ToUpper(strings.TrimSpace(string(existing.Status)))
					requestedStatus := strings.ToUpper(strings.TrimSpace(stringValue(recordInput.Status)))
					allowRejectedCorrection := existingStatus == "REJECTED" && requestedStatus == "PENDING"
					if existingStatus != "PENDING" && !allowRejectedCorrection {
						return fmt.Errorf("cannot update record with status %s", existing.Status)
					}

					updatedRecord, updateErr := r.updateHarvestRecordFromSync(
						ctx,
						scopedPanenResolver,
						*recordInput.ServerID,
						recordInput,
						effectiveDeviceID,
						effectiveKaryawanID,
						effectiveNik,
						effectiveEmployeeDivisionID,
						effectiveEmployeeDivisionName,
						allowRejectedCorrection,
					)
					if updateErr != nil {
						return updateErr
					}

					record = updatedRecord
					recordUpdated = true
					return nil
				}
			}

			// CREATE: No server ID or server record not found.
			if !isUpdate {
				existing, findErr := scopedPanenResolver.GetByLocalID(ctx, recordInput.LocalID, effectiveMandorID)
				if findErr == nil && existing != nil {
					// Record already exists by LocalID - treat as success (idempotent).
					record = (*mandor.HarvestRecord)(existing)
					return nil
				}

				localID := recordInput.LocalID
				var localIDPtr *string
				if localID != "" {
					localIDPtr = &localID
				}

				createInput := mandor.CreateHarvestRecordInput{
					LocalID:       localIDPtr,
					DeviceID:      stringPointerIfNotEmpty(effectiveDeviceID),
					Tanggal:       recordInput.Tanggal,
					MandorID:      effectiveMandorID,
					BlockID:       recordInput.BlockID,
					Karyawan:      *effectiveNik,
					JumlahJanjang: int32(recordInput.JumlahJanjang),
					BeratTbs:      recordInput.BeratTbs,
				}

				// Add optional fields from sync input.
				if recordInput.Notes != nil {
					createInput.Notes = recordInput.Notes
				}
				if recordInput.JjgMatang != nil {
					createInput.JjgMatang = recordInput.JjgMatang
				}
				if recordInput.JjgMentah != nil {
					createInput.JjgMentah = recordInput.JjgMentah
				}
				if recordInput.JjgLewatMatang != nil {
					createInput.JjgLewatMatang = recordInput.JjgLewatMatang
				}
				if recordInput.JjgBusukAbnormal != nil {
					createInput.JjgBusukAbnormal = recordInput.JjgBusukAbnormal
				}
				if recordInput.JjgTangkaiPanjang != nil {
					createInput.JjgTangkaiPanjang = recordInput.JjgTangkaiPanjang
				}
				if recordInput.TotalBrondolan != nil {
					createInput.TotalBrondolan = recordInput.TotalBrondolan
				}
				if recordInput.Latitude != nil {
					createInput.Latitude = recordInput.Latitude
				}
				if recordInput.Longitude != nil {
					createInput.Longitude = recordInput.Longitude
				}
				if recordInput.CompanyID != nil {
					createInput.CompanyID = recordInput.CompanyID
				}
				if recordInput.EstateID != nil {
					createInput.EstateID = recordInput.EstateID
				}
				if recordInput.DivisionID != nil {
					createInput.DivisionID = recordInput.DivisionID
				}
				if effectiveEmployeeDivisionID != nil {
					createInput.EmployeeDivisionID = effectiveEmployeeDivisionID
				}
				if effectiveEmployeeDivisionName != nil {
					createInput.EmployeeDivisionName = effectiveEmployeeDivisionName
				}
				createInput.KaryawanID = effectiveKaryawanID

				if recordInput.PhotoURL != nil {
					photoValue := strings.TrimSpace(*recordInput.PhotoURL)
					if photoValue != "" {
						resolvedPhotoURL, photoErr := r.saveHarvestPhotoFromPayload(recordInput.LocalID, photoValue)
						if photoErr != nil {
							return fmt.Errorf("failed to process harvest photo: %w", photoErr)
						}
						createInput.PhotoURL = &resolvedPhotoURL
					}
				}

				model, createErr := scopedPanenResolver.CreateHarvestRecord(ctx, createInput)
				if createErr != nil {
					return createErr
				}
				if enforceErr := r.enforceSyncIdentity(
					ctx,
					scopedPanenResolver,
					model,
					effectiveKaryawanID,
					effectiveNik,
					effectiveEmployeeDivisionID,
					effectiveEmployeeDivisionName,
				); enforceErr != nil {
					return enforceErr
				}

				record = (*mandor.HarvestRecord)(model)
				createdModel = model
				recordCreated = true
			}

			return nil
		})

		itemResult := &mandor.MandorSyncItemResult{
			LocalID: recordInput.LocalID,
		}

		if err != nil {
			failureCount++
			if conflictResolutionFailed {
				conflictsDetected++
			}
			errMsg := err.Error()
			itemResult.Success = false
			itemResult.Status = common.SyncItemStatusRejected
			itemResult.Error = &errMsg
		} else {
			successCount++
			if recordConflict {
				conflictsDetected++
			}
			if recordUpdated {
				updatedCount++
			}
			if recordCreated {
				createdCount++
				r.notifyAsistenHarvestCreated(ctx, createdModel)
				publishHarvestRecordCreated((*mandor.HarvestRecord)(createdModel))
			}
			itemResult.Success = true
			itemResult.Status = common.SyncItemStatusAccepted
			if record != nil {
				itemResult.ServerID = &record.ID
			}
		}
		syncResults = append(syncResults, itemResult)
	}

	transactionID := fmt.Sprintf("txn_%d", time.Now().UnixNano())

	// Build detailed message
	message := fmt.Sprintf("Processed %d records (%d created, %d updated)", len(input.Records), createdCount, updatedCount)
	if conflictsDetected > 0 {
		message = fmt.Sprintf("%s, %d conflicts resolved", message, conflictsDetected)
	}

	return &mandor.MandorSyncResult{
		Success:           failureCount == 0,
		TransactionID:     transactionID,
		RecordsProcessed:  int32(len(input.Records)),
		RecordsSuccessful: int32(successCount),
		RecordsFailed:     int32(failureCount),
		ConflictsDetected: int32(conflictsDetected),
		Results:           syncResults,
		ServerTimestamp:   time.Now(),
		Message:           message,
	}, nil
}

func (r *mutationResolver) notifyAsistenHarvestCreated(ctx context.Context, record *panenModels.HarvestRecord) {
	if record == nil {
		return
	}

	mandorID := strings.TrimSpace(record.MandorID)
	if mandorID == "" {
		return
	}

	mandorName := "Mandor"
	if record.Mandor != nil {
		if name := strings.TrimSpace(record.Mandor.Name); name != "" {
			mandorName = name
		} else if username := strings.TrimSpace(record.Mandor.Username); username != "" {
			mandorName = username
		}
	}

	blockName := "Block"
	if record.Block != nil {
		if name := strings.TrimSpace(record.Block.Name); name != "" {
			blockName = name
		}
	}

	harvestID := strings.TrimSpace(record.ID)
	bunchCount := record.JumlahJanjang

	notifier := r.FCMNotificationService
	if !isNilValue(notifier) {
		go func(notifier HarvestFCMNotifier) {
			err := notifier.NotifyAsistenNewHarvest(
				context.Background(),
				harvestID,
				mandorID,
				mandorName,
				blockName,
				bunchCount,
			)
			if err != nil {
				log.Printf(
					"Failed to send FCM notification to asisten for harvest %s (mandor %s): %v",
					harvestID,
					mandorID,
					err,
				)
			}
		}(notifier)
	}

	if r.NotificationService != nil {
		go func() {
			if err := r.notifyHarvestCreatedHierarchyNotifications(
				context.Background(),
				harvestID,
				mandorID,
				mandorName,
				blockName,
				record.BeratTbs,
			); err != nil {
				log.Printf(
					"Failed to create hierarchical harvest-created notification for harvest %s: %v",
					harvestID,
					err,
				)
			}
		}()
	}
}

type harvestNotificationRecipient struct {
	UserID string
	Role   auth.UserRole
}

func (r *mutationResolver) notifyHarvestCreatedHierarchyNotifications(
	ctx context.Context,
	harvestID string,
	mandorID string,
	mandorName string,
	blockName string,
	weight float64,
) error {
	if r.NotificationService == nil {
		return nil
	}

	recipients, err := r.resolveHarvestCreatedRecipients(ctx, mandorID)
	if err != nil {
		return err
	}

	// Fallback keeps old behavior if hierarchy mapping is unavailable.
	if len(recipients) == 0 {
		return r.NotificationService.NotifyHarvestCreated(
			ctx,
			harvestID,
			mandorID,
			mandorName,
			blockName,
			weight,
		)
	}

	metadata := map[string]interface{}{
		"harvestId":  harvestID,
		"mandorId":   mandorID,
		"mandorName": mandorName,
		"block":      blockName,
		"weight":     weight,
	}

	for _, recipient := range recipients {
		actionURL := "/approvals"
		actionLabel := "Review"
		switch recipient.Role {
		case auth.UserRoleAsisten:
			actionURL = "/dashboard/asisten/approval"
		case auth.UserRoleManager:
			actionURL = "/dashboard/manager/approval"
		}

		input := &notificationServices.CreateNotificationInput{
			Type:              notificationModels.NotificationTypeHarvestApprovalNeeded,
			Priority:          notificationModels.NotificationPriorityHigh,
			Title:             "Persetujuan Panen Diperlukan",
			Message:           fmt.Sprintf("Data panen baru dari %s di blok %s (%.1f kg) memerlukan persetujuan", mandorName, blockName, weight),
			RecipientID:       recipient.UserID,
			RelatedEntityType: "HARVEST_RECORD",
			RelatedEntityID:   harvestID,
			ActionURL:         actionURL,
			ActionLabel:       actionLabel,
			Metadata:          metadata,
			SenderID:          mandorID,
			SenderRole:        string(auth.UserRoleMandor),
			IdempotencyKey:    fmt.Sprintf("harvest-created:%s:%s", harvestID, recipient.UserID),
		}

		if _, createErr := r.NotificationService.CreateNotification(ctx, input); createErr != nil {
			return createErr
		}
	}

	return nil
}

func (r *mutationResolver) resolveHarvestCreatedRecipients(
	ctx context.Context,
	mandorID string,
) ([]harvestNotificationRecipient, error) {
	if r.HierarchyService == nil {
		return nil, nil
	}

	asisten, err := r.HierarchyService.GetParent(ctx, mandorID)
	if err != nil {
		return nil, err
	}
	if asisten == nil {
		return nil, nil
	}

	recipients := make([]harvestNotificationRecipient, 0, 2)
	seen := make(map[string]struct{}, 2)
	appendRecipient := func(userID string, role auth.UserRole) {
		id := strings.TrimSpace(userID)
		if id == "" {
			return
		}
		if _, exists := seen[id]; exists {
			return
		}
		seen[id] = struct{}{}
		recipients = append(recipients, harvestNotificationRecipient{
			UserID: id,
			Role:   role,
		})
	}

	// Primary target: direct supervisor of mandor.
	switch asisten.Role {
	case auth.UserRoleAsisten, auth.UserRoleManager:
		appendRecipient(asisten.ID, asisten.Role)
	}

	// Secondary target: direct supervisor of asisten (manager).
	manager, err := r.HierarchyService.GetParent(ctx, asisten.ID)
	if err != nil {
		return nil, err
	}
	if manager != nil && manager.Role == auth.UserRoleManager {
		appendRecipient(manager.ID, manager.Role)
	}

	return recipients, nil
}

type harvestApprovalFCMNotifier interface {
	NotifyMandorApproved(
		ctx context.Context,
		harvestID string,
		mandorID string,
		asistenName string,
		blockName string,
		harvestDate string,
		bunchCount int32,
	) error
}

type harvestRejectionFCMNotifier interface {
	NotifyMandorRejected(
		ctx context.Context,
		harvestID string,
		mandorID string,
		asistenName string,
		blockName string,
		reason string,
		harvestDate string,
		bunchCount int32,
	) error
}

func (r *mutationResolver) notifyMandorHarvestApproved(
	ctx context.Context,
	record *panenModels.HarvestRecord,
	approverID string,
) {
	if record == nil {
		return
	}

	mandorID := strings.TrimSpace(record.MandorID)
	harvestID := strings.TrimSpace(record.ID)
	if mandorID == "" || harvestID == "" {
		return
	}

	asistenName := r.resolveApproverName(ctx, approverID)
	blockName := r.resolveHarvestBlockName(ctx, record)
	harvestDate := record.Tanggal.Format("02/01/2006")
	bunchCount := record.JumlahJanjang

	if !isNilValue(r.FCMNotificationService) {
		if notifier, ok := r.FCMNotificationService.(harvestApprovalFCMNotifier); ok && !isNilValue(notifier) {
			go func() {
				err := notifier.NotifyMandorApproved(
					context.Background(),
					harvestID,
					mandorID,
					asistenName,
					blockName,
					harvestDate,
					bunchCount,
				)
				if err != nil {
					log.Printf(
						"Failed to send FCM approval notification to mandor %s for harvest %s: %v",
						mandorID,
						harvestID,
						err,
					)
				}
			}()
		}
	}

	if r.NotificationService != nil {
		go func() {
			if err := r.NotificationService.NotifyHarvestApproved(
				context.Background(),
				harvestID,
				mandorID,
				approverID,
				blockName,
				record.BeratTbs,
			); err != nil {
				log.Printf(
					"Failed to create harvest-approved notification for harvest %s: %v",
					harvestID,
					err,
				)
			}
		}()
	}
}

func (r *mutationResolver) notifyMandorHarvestRejected(
	ctx context.Context,
	record *panenModels.HarvestRecord,
	reason string,
	approverID string,
) {
	if record == nil {
		return
	}

	mandorID := strings.TrimSpace(record.MandorID)
	harvestID := strings.TrimSpace(record.ID)
	if mandorID == "" || harvestID == "" {
		return
	}

	asistenName := r.resolveApproverName(ctx, approverID)
	blockName := r.resolveHarvestBlockName(ctx, record)
	rejectedReason := strings.TrimSpace(reason)
	if rejectedReason == "" {
		rejectedReason = "Data panen ditolak"
	}
	harvestDate := record.Tanggal.Format("02/01/2006")
	bunchCount := record.JumlahJanjang

	if !isNilValue(r.FCMNotificationService) {
		if notifier, ok := r.FCMNotificationService.(harvestRejectionFCMNotifier); ok && !isNilValue(notifier) {
			go func() {
				err := notifier.NotifyMandorRejected(
					context.Background(),
					harvestID,
					mandorID,
					asistenName,
					blockName,
					rejectedReason,
					harvestDate,
					bunchCount,
				)
				if err != nil {
					log.Printf(
						"Failed to send FCM rejection notification to mandor %s for harvest %s: %v",
						mandorID,
						harvestID,
						err,
					)
				}
			}()
		}
	}

	if r.NotificationService != nil {
		go func() {
			if err := r.NotificationService.NotifyHarvestRejected(
				context.Background(),
				harvestID,
				mandorID,
				approverID,
				blockName,
				record.BeratTbs,
				rejectedReason,
			); err != nil {
				log.Printf(
					"Failed to create harvest-rejected notification for harvest %s: %v",
					harvestID,
					err,
				)
			}
		}()
	}
}

func (r *mutationResolver) resolveApproverName(ctx context.Context, approverID string) string {
	candidateID := strings.TrimSpace(approverID)
	if candidateID == "" {
		candidateID = strings.TrimSpace(middleware.GetCurrentUserID(ctx))
	}

	if candidateID != "" {
		var user struct {
			Name     string
			Username string
		}
		if err := r.db.WithContext(ctx).
			Table("users").
			Select("name, username").
			Where("id = ?", candidateID).
			Take(&user).Error; err == nil {
			if name := strings.TrimSpace(user.Name); name != "" {
				return name
			}
			if username := strings.TrimSpace(user.Username); username != "" {
				return username
			}
		}
	}

	return "Asisten"
}

func (r *mutationResolver) resolveHarvestBlockName(ctx context.Context, record *panenModels.HarvestRecord) string {
	if record != nil && record.Block != nil {
		if name := strings.TrimSpace(record.Block.Name); name != "" {
			return name
		}
	}
	if record == nil {
		return "Block"
	}

	blockID := strings.TrimSpace(record.BlockID)
	if blockID == "" {
		return "Block"
	}

	var block struct {
		Name string
	}
	if err := r.db.WithContext(ctx).
		Table("blocks").
		Select("name").
		Where("id = ?", blockID).
		Take(&block).Error; err == nil {
		if name := strings.TrimSpace(block.Name); name != "" {
			return name
		}
	}

	return "Block"
}

func isNilValue(value interface{}) bool {
	if value == nil {
		return true
	}

	switch reflect.ValueOf(value).Kind() {
	case reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Pointer, reflect.Slice:
		return reflect.ValueOf(value).IsNil()
	default:
		return false
	}
}

func getCurrentUserScope(ctx context.Context) (string, auth.UserRole) {
	userID := strings.TrimSpace(middleware.GetCurrentUserID(ctx))
	role := middleware.GetUserRoleFromContext(ctx)
	return userID, role
}

func (r *queryResolver) buildScopedHarvestFilters(
	ctx context.Context,
	userID string,
	role auth.UserRole,
	base *panenModels.HarvestFilters,
) (*panenModels.HarvestFilters, bool, error) {
	if strings.TrimSpace(userID) == "" {
		return nil, false, fmt.Errorf("authentication required")
	}
	if r.MasterResolver == nil || r.MasterResolver.GetMasterService() == nil {
		return nil, false, fmt.Errorf("master service unavailable")
	}

	assignments, err := r.MasterResolver.GetMasterService().GetUserAssignments(ctx, userID)
	if err != nil {
		return nil, false, fmt.Errorf("failed to load user assignments: %w", err)
	}

	companyIDs := make([]string, 0, len(assignments.Companies))
	estateIDs := make([]string, 0, len(assignments.Estates))
	divisionIDs := make([]string, 0, len(assignments.Divisions))
	companySeen := make(map[string]struct{}, len(assignments.Companies))
	estateSeen := make(map[string]struct{}, len(assignments.Estates))
	divisionSeen := make(map[string]struct{}, len(assignments.Divisions))

	for _, company := range assignments.Companies {
		companyIDs = appendUniqueHarvestScopeID(companyIDs, companySeen, company.ID)
	}
	for _, estate := range assignments.Estates {
		estateIDs = appendUniqueHarvestScopeID(estateIDs, estateSeen, estate.ID)
	}
	for _, division := range assignments.Divisions {
		divisionIDs = appendUniqueHarvestScopeID(divisionIDs, divisionSeen, division.ID)
	}

	filters := &panenModels.HarvestFilters{}
	if base != nil {
		*filters = *base
		filters.MandorIDs = append([]string(nil), base.MandorIDs...)
		filters.CompanyIDs = append([]string(nil), base.CompanyIDs...)
		filters.EstateIDs = append([]string(nil), base.EstateIDs...)
		filters.DivisionIDs = append([]string(nil), base.DivisionIDs...)
	}

	// Reset scope dimensions and set exactly one role-priority scope.
	filters.CompanyIDs = nil
	filters.EstateIDs = nil
	filters.DivisionIDs = nil

	switch role {
	case auth.UserRoleManager:
		if len(estateIDs) > 0 {
			filters.EstateIDs = estateIDs
			return filters, true, nil
		}
	case auth.UserRoleAsisten:
		if len(divisionIDs) > 0 {
			filters.DivisionIDs = divisionIDs
			return filters, true, nil
		}
	case auth.UserRoleAreaManager, auth.UserRoleCompanyAdmin:
		if len(companyIDs) > 0 {
			filters.CompanyIDs = companyIDs
			return filters, true, nil
		}
	}

	return nil, false, nil
}

func (r *queryResolver) buildHierarchyMandorScopedHarvestFilters(
	ctx context.Context,
	userID string,
	base *panenModels.HarvestFilters,
) (*panenModels.HarvestFilters, bool, error) {
	mandorIDs, err := r.getHierarchyMandorIDs(ctx, userID)
	if err != nil {
		return nil, false, err
	}
	if len(mandorIDs) == 0 {
		return nil, false, nil
	}

	filters := &panenModels.HarvestFilters{}
	if base != nil {
		*filters = *base
		filters.MandorIDs = append([]string(nil), base.MandorIDs...)
		filters.CompanyIDs = append([]string(nil), base.CompanyIDs...)
		filters.EstateIDs = append([]string(nil), base.EstateIDs...)
		filters.DivisionIDs = append([]string(nil), base.DivisionIDs...)
	}
	filters.MandorIDs = mandorIDs

	return filters, true, nil
}

func (r *queryResolver) getHierarchyMandorIDs(ctx context.Context, userID string) ([]string, error) {
	if strings.TrimSpace(userID) == "" {
		return nil, fmt.Errorf("authentication required")
	}
	if r.HierarchyService == nil {
		return nil, fmt.Errorf("hierarchy service unavailable")
	}

	queue := []string{userID}
	visited := map[string]struct{}{userID: {}}
	mandorSeen := make(map[string]struct{})
	mandorIDs := make([]string, 0)

	for len(queue) > 0 {
		currentID := queue[0]
		queue = queue[1:]

		children, err := r.HierarchyService.GetChildren(ctx, currentID)
		if err != nil {
			return nil, fmt.Errorf("failed to load hierarchy children: %w", err)
		}

		for _, child := range children {
			if child == nil {
				continue
			}

			childID := strings.TrimSpace(child.ID)
			if childID == "" {
				continue
			}

			if child.Role == auth.UserRoleMandor {
				if _, exists := mandorSeen[childID]; !exists {
					mandorSeen[childID] = struct{}{}
					mandorIDs = append(mandorIDs, childID)
				}
			}

			if _, seen := visited[childID]; seen {
				continue
			}
			visited[childID] = struct{}{}
			queue = append(queue, childID)
		}
	}

	return mandorIDs, nil
}

func appendUniqueHarvestScopeID(target []string, seen map[string]struct{}, raw string) []string {
	id := strings.TrimSpace(raw)
	if id == "" {
		return target
	}
	if _, exists := seen[id]; exists {
		return target
	}
	seen[id] = struct{}{}
	return append(target, id)
}

func harvestScopeContains(scope []string, value string) bool {
	target := strings.TrimSpace(value)
	if target == "" {
		return false
	}
	for _, scopeID := range scope {
		if strings.EqualFold(strings.TrimSpace(scopeID), target) {
			return true
		}
	}
	return false
}

func isHarvestRecordInScopedAssignments(record *panenModels.HarvestRecord, filters *panenModels.HarvestFilters) bool {
	if record == nil || filters == nil {
		return false
	}

	if len(filters.CompanyIDs) > 0 {
		if record.CompanyID == nil || !harvestScopeContains(filters.CompanyIDs, *record.CompanyID) {
			return false
		}
	}
	if len(filters.EstateIDs) > 0 {
		if record.EstateID == nil || !harvestScopeContains(filters.EstateIDs, *record.EstateID) {
			return false
		}
	}
	if len(filters.DivisionIDs) > 0 {
		if record.DivisionID == nil || !harvestScopeContains(filters.DivisionIDs, *record.DivisionID) {
			return false
		}
	}
	if len(filters.MandorIDs) > 0 {
		if strings.TrimSpace(record.MandorID) == "" || !harvestScopeContains(filters.MandorIDs, record.MandorID) {
			return false
		}
	}

	return true
}

func (r *mutationResolver) ensureManagerCanAccessHarvest(
	ctx context.Context,
	managerID string,
	harvestID string,
) error {
	record, err := r.PanenResolver.HarvestRecordByManager(ctx, harvestID, managerID)
	if err != nil {
		var harvestErr *panenModels.HarvestError
		if errors.As(err, &harvestErr) && harvestErr.Code == panenModels.ErrHarvestNotFound {
			return fmt.Errorf("harvest record not found")
		}
		return err
	}
	if record == nil {
		return fmt.Errorf("harvest record not found")
	}

	return nil
}

func (r *mutationResolver) saveHarvestPhotoFromPayload(localID string, photoValue string) (string, error) {
	trimmed := strings.TrimSpace(photoValue)
	if trimmed == "" {
		return "", nil
	}

	if !strings.HasPrefix(strings.ToLower(trimmed), "data:image/") {
		return trimmed, nil
	}

	parts := strings.SplitN(trimmed, ",", 2)
	if len(parts) != 2 {
		return "", fmt.Errorf("invalid photo data URI")
	}

	header := strings.ToLower(strings.TrimSpace(parts[0]))
	if !strings.Contains(header, ";base64") {
		return "", fmt.Errorf("photo payload must be base64 data URI")
	}

	mimeType := "image/jpeg"
	if strings.HasPrefix(header, "data:") {
		rawMime := strings.TrimPrefix(header, "data:")
		rawMime = strings.SplitN(rawMime, ";", 2)[0]
		if rawMime != "" {
			mimeType = rawMime
		}
	}

	photoBytes, err := base64.StdEncoding.DecodeString(parts[1])
	if err != nil {
		photoBytes, err = base64.RawStdEncoding.DecodeString(parts[1])
		if err != nil {
			return "", fmt.Errorf("invalid base64 photo data: %w", err)
		}
	}

	uploadDir := r.uploadAbsolutePath("harvest_photos")
	if err := os.MkdirAll(uploadDir, 0755); err != nil {
		return "", fmt.Errorf("failed to create upload dir: %w", err)
	}

	ext := fileExtensionFromMimeType(mimeType)
	filePrefix := sanitizeFileComponent(localID)
	if filePrefix == "" {
		filePrefix = "harvest"
	}

	filename := fmt.Sprintf("%s_%d%s", filePrefix, time.Now().UnixNano(), ext)
	absolutePath := filepath.Join(uploadDir, filename)
	if err := os.WriteFile(absolutePath, photoBytes, 0644); err != nil {
		return "", fmt.Errorf("failed to save photo file: %w", err)
	}

	return uploadURLPath("harvest_photos", filename), nil
}

func fileExtensionFromMimeType(mimeType string) string {
	switch strings.ToLower(strings.TrimSpace(mimeType)) {
	case "image/png":
		return ".png"
	case "image/webp":
		return ".webp"
	case "image/heic":
		return ".heic"
	case "image/heif":
		return ".heif"
	default:
		return ".jpg"
	}
}

var nonFileSafeChars = regexp.MustCompile(`[^a-zA-Z0-9_-]`)

func sanitizeFileComponent(value string) string {
	normalized := strings.TrimSpace(value)
	if normalized == "" {
		return ""
	}
	return nonFileSafeChars.ReplaceAllString(normalized, "_")
}

// updateHarvestRecordFromSync updates an existing harvest record from sync input
func (r *mutationResolver) updateHarvestRecordFromSync(
	ctx context.Context,
	panenResolver *panenResolvers.PanenResolver,
	serverID string,
	input *mandor.HarvestRecordSyncInput,
	deviceID string,
	karyawanID *string,
	nik *string,
	employeeDivisionID *string,
	employeeDivisionName *string,
	resetStatusToPending bool,
) (*mandor.HarvestRecord, error) {
	var karyawanPtr *string
	if nik != nil {
		karyawanPtr = nik
	}

	// Build update input
	updateInput := mandor.UpdateHarvestRecordInput{
		ID:                   serverID,
		DeviceID:             stringPointerIfNotEmpty(deviceID),
		KaryawanID:           karyawanID,
		EmployeeDivisionID:   employeeDivisionID,
		EmployeeDivisionName: employeeDivisionName,
		Karyawan:             karyawanPtr,
		JumlahJanjang:        &input.JumlahJanjang,
		BeratTbs:             &input.BeratTbs,
	}
	if input.JjgMatang != nil {
		updateInput.JjgMatang = input.JjgMatang
	}
	if input.JjgMentah != nil {
		updateInput.JjgMentah = input.JjgMentah
	}
	if input.JjgLewatMatang != nil {
		updateInput.JjgLewatMatang = input.JjgLewatMatang
	}
	if input.JjgBusukAbnormal != nil {
		updateInput.JjgBusukAbnormal = input.JjgBusukAbnormal
	}
	if input.JjgTangkaiPanjang != nil {
		updateInput.JjgTangkaiPanjang = input.JjgTangkaiPanjang
	}
	if input.TotalBrondolan != nil {
		updateInput.TotalBrondolan = input.TotalBrondolan
	}

	// Call the update service
	updated, err := panenResolver.UpdateHarvestRecord(ctx, updateInput)
	if err != nil {
		return nil, fmt.Errorf("failed to update harvest record: %w", err)
	}

	updatedModel := (*panenModels.HarvestRecord)(updated)
	if input.PhotoURL != nil {
		photoValue := strings.TrimSpace(*input.PhotoURL)
		if photoValue == "" {
			updatedModel.PhotoURL = nil
		} else {
			resolvedPhotoURL, photoErr := r.saveHarvestPhotoFromPayload(input.LocalID, photoValue)
			if photoErr != nil {
				return nil, fmt.Errorf("failed to process harvest photo: %w", photoErr)
			}
			updatedModel.PhotoURL = &resolvedPhotoURL
		}
	}
	if err := r.enforceSyncIdentity(
		ctx,
		panenResolver,
		updatedModel,
		karyawanID,
		nik,
		employeeDivisionID,
		employeeDivisionName,
	); err != nil {
		return nil, fmt.Errorf("failed to apply sync identity: %w", err)
	}

	// Correction flow: when mandor edits rejected data and resubmits,
	// move status back to PENDING so it re-enters asisten approval queue.
	if resetStatusToPending {
		pending := panenModels.HarvestPending
		updatedModel.Status = pending
		updatedModel.RejectedReason = nil
		updatedModel.ApprovedAt = nil
		updatedModel.ApprovedBy = nil
		if err := panenResolver.SaveHarvestRecord(ctx, updatedModel); err != nil {
			return nil, fmt.Errorf("failed to reset corrected harvest status to pending: %w", err)
		}
	}

	return (*mandor.HarvestRecord)(updatedModel), nil
}

// checkAndResolveConflict detects conflicts between existing server record and incoming client data
// Returns (isConflict, error)
// Strategy: Server-authoritative - if server record was updated after client's lastUpdated, server wins
func (r *mutationResolver) checkAndResolveConflict(
	ctx context.Context,
	existing *panenModels.HarvestRecord,
	input *mandor.HarvestRecordSyncInput,
	deviceID string,
	karyawanID *string,
	nik *string,
) (bool, error) {
	// If no lastUpdated from client, no conflict detection possible - allow sync
	if input.LastUpdated == nil {
		return false, nil
	}

	clientLastUpdated := *input.LastUpdated
	serverUpdatedAt := existing.UpdatedAt

	// If server record was updated after client's lastUpdated, there's a conflict
	if serverUpdatedAt.After(clientLastUpdated) {
		// Server-authoritative: Server version wins
		// Log the conflict for audit purposes
		fmt.Printf("âš ï¸ [Conflict Detected] LocalID=%s, ClientUpdated=%v, ServerUpdated=%v - Server wins\n",
			input.LocalID, clientLastUpdated, serverUpdatedAt)

		// Don't update - return existing record as-is (server wins)
		// The client will receive the server version in the sync response
		return true, nil
	}

	// No conflict - caller will perform exactly one update write path.
	_ = ctx
	_ = existing
	_ = input
	_ = deviceID
	_ = karyawanID
	_ = nik
	return false, nil
}

func (r *mutationResolver) resolveHarvestNikFromSyncInput(
	input *mandor.HarvestRecordSyncInput,
	nik *string,
) *string {
	if nik != nil {
		return nik
	}
	if input == nil {
		return nil
	}
	return normalizeSyncNik(input.Nik)
}

func (r *mutationResolver) enforceSyncIdentity(
	ctx context.Context,
	panenResolver *panenResolvers.PanenResolver,
	record *panenModels.HarvestRecord,
	karyawanID *string,
	nik *string,
	employeeDivisionID *string,
	employeeDivisionName *string,
) error {
	if record == nil {
		return nil
	}
	if karyawanID != nil {
		record.KaryawanID = karyawanID
	}
	record.Nik = nik
	if employeeDivisionID != nil {
		record.EmployeeDivisionID = employeeDivisionID
	}
	if employeeDivisionName != nil {
		record.EmployeeDivisionName = employeeDivisionName
	}
	return panenResolver.SaveHarvestRecord(ctx, record)
}

func normalizeSyncKaryawanID(karyawanID string) *string {
	trimmed := strings.TrimSpace(karyawanID)
	if !isUuidString(trimmed) {
		return nil
	}
	return &trimmed
}

func normalizeSyncNik(nik string) *string {
	trimmed := strings.TrimSpace(nik)
	if trimmed == "" {
		return nil
	}
	return &trimmed
}

func stringPointerIfNotEmpty(value string) *string {
	trimmed := strings.TrimSpace(value)
	if trimmed == "" {
		return nil
	}
	return &trimmed
}

func normalizeSyncOptionalUUID(value *string) *string {
	if value == nil {
		return nil
	}
	trimmed := strings.TrimSpace(*value)
	if !isUuidString(trimmed) {
		return nil
	}
	return &trimmed
}

func normalizeSyncOptionalText(value *string) *string {
	if value == nil {
		return nil
	}
	trimmed := strings.TrimSpace(*value)
	if trimmed == "" {
		return nil
	}
	return &trimmed
}

func harvestWorkerLabel(karyawan string, nik *string, karyawanID *string) string {
	trimmedKaryawan := strings.TrimSpace(karyawan)
	if trimmedKaryawan != "" {
		return trimmedKaryawan
	}
	if nik != nil {
		trimmedNik := strings.TrimSpace(*nik)
		if trimmedNik != "" {
			return trimmedNik
		}
	}
	if karyawanID != nil {
		trimmedKaryawanID := strings.TrimSpace(*karyawanID)
		if trimmedKaryawanID != "" {
			return trimmedKaryawanID
		}
	}

	return ""
}

func isUuidString(value string) bool {
	_, err := uuid.Parse(strings.TrimSpace(value))
	return err == nil
}

// MandorDashboard is the resolver for the mandorDashboard field.
func (r *queryResolver) MandorDashboard(ctx context.Context) (*mandor.MandorDashboardData, error) {
	// Get the authenticated user's ID from context
	userID, ok := ctx.Value("user_id").(string)
	if !ok || userID == "" {
		return nil, fmt.Errorf("user not authenticated")
	}

	// Get dashboard stats
	stats, err := r.PanenResolver.GetMandorDashboardStats(ctx, userID)
	if err != nil {
		return nil, err
	}

	// Get recent activities
	activities, err := r.PanenResolver.GetMandorActivities(ctx, userID, 5)
	if err != nil {
		activities = []*mandor.MandorActivity{}
	}

	// Build dashboard data (some fields need additional queries)
	return &mandor.MandorDashboardData{
		User:               nil, // Would need to fetch user details
		Divisions:          []*master.Division{},
		Stats:              stats,
		RecentActivities:   activities,
		PendingSubmissions: []*mandor.MandorHarvestSummary{},
		TodayWork: &mandor.MandorTodayWork{
			HarvestsCreated: stats.TodayHarvestCount,
			TotalTbs:        stats.TodayTbsCount,
			TotalWeight:     stats.TodayWeight,
			WorkersInvolved: stats.ActiveWorkers,
			BlocksCompleted: stats.BlocksWorkedToday,
		},
		SyncStatus: &mandor.MandorSyncStatus{
			IsOnline:            true,
			PendingSyncCount:    0,
			FailedSyncCount:     0,
			PhotosPendingUpload: 0,
		},
	}, nil
}

// MandorDashboardStats is the resolver for the mandorDashboardStats field.
func (r *queryResolver) MandorDashboardStats(ctx context.Context) (*mandor.MandorDashboardStats, error) {
	// Get the authenticated user's ID from context
	userID, ok := ctx.Value("user_id").(string)
	if !ok || userID == "" {
		return nil, fmt.Errorf("user not authenticated")
	}

	return r.PanenResolver.GetMandorDashboardStats(ctx, userID)
}

// MandorActivities is the resolver for the mandorActivities field.
func (r *queryResolver) MandorActivities(ctx context.Context, limit *int32) ([]*mandor.MandorActivity, error) {
	userID, ok := ctx.Value("user_id").(string)
	if !ok || userID == "" {
		return nil, fmt.Errorf("user not authenticated")
	}

	limitVal := 20
	if limit != nil && *limit > 0 {
		limitVal = int(*limit)
	}

	return r.PanenResolver.GetMandorActivities(ctx, userID, limitVal)
}

// MandorSyncStatus is the resolver for the mandorSyncStatus field.
func (r *queryResolver) MandorSyncStatus(ctx context.Context) (*mandor.MandorSyncStatus, error) {
	// Sync status is primarily client-side state
	// Server returns default values indicating no pending server-side operations
	return &mandor.MandorSyncStatus{
		IsOnline:            true,
		LastSyncAt:          nil,
		PendingSyncCount:    0,
		FailedSyncCount:     0,
		LastSyncResult:      nil,
		PhotosPendingUpload: 0,
	}, nil
}

// MandorBlocks is the resolver for the mandorBlocks field.
func (r *queryResolver) MandorBlocks(ctx context.Context, divisionID *string) ([]*master.Block, error) {
	userID, ok := ctx.Value("user_id").(string)
	if !ok || userID == "" {
		return nil, fmt.Errorf("user not authenticated")
	}

	// Get user's division assignments
	var assignedDivisionIDs []string
	if err := r.db.WithContext(ctx).
		Table("user_division_assignments").
		Select("division_id").
		Where("user_id = ? AND is_active = true", userID).
		Pluck("division_id", &assignedDivisionIDs).Error; err != nil {
		return nil, fmt.Errorf("failed to get division assignments: %w", err)
	}

	// If no division assignments, return empty list
	if len(assignedDivisionIDs) == 0 {
		return []*master.Block{}, nil
	}

	// Query blocks available to this mandor
	var blocks []*master.Block
	query := r.db.WithContext(ctx).Model(&master.Block{})

	// Filter by specific division if provided
	if divisionID != nil && *divisionID != "" {
		// Validate user has access to this division
		hasAccess := false
		for _, id := range assignedDivisionIDs {
			if id == *divisionID {
				hasAccess = true
				break
			}
		}
		if !hasAccess {
			return nil, fmt.Errorf("access denied to division")
		}
		query = query.Where("division_id = ?", *divisionID)
	} else {
		// Return blocks from all assigned divisions
		query = query.Where("division_id IN ?", assignedDivisionIDs)
	}

	if err := query.Where("is_active = ?", true).Find(&blocks).Error; err != nil {
		return nil, fmt.Errorf("failed to get blocks: %w", err)
	}

	return blocks, nil
}

// MandorEmployees is the resolver for the mandorEmployees field.
func (r *queryResolver) MandorEmployees(ctx context.Context, divisionID *string, search *string) ([]*master.Employee, error) {
	userID, ok := ctx.Value("user_id").(string)
	if !ok || userID == "" {
		return nil, fmt.Errorf("user not authenticated")
	}

	// Get user's company_id from context
	companyID, _ := ctx.Value("company_id").(string)

	// Query employees available to this mandor
	var employees []*master.Employee
	query := r.db.WithContext(ctx).Model(&master.Employee{})

	// Filter by company (employees belong to same company as mandor)
	if companyID != "" {
		query = query.Where("company_id = ?", companyID)
	}

	// Filter by division if provided (employees may have division assignment)
	if divisionID != nil && *divisionID != "" {
		query = query.Where("division_id = ?", *divisionID)
	}

	// Search by name or NIK
	if search != nil && *search != "" {
		searchPattern := "%" + *search + "%"
		query = query.Where("name ILIKE ? OR nik ILIKE ?", searchPattern, searchPattern)
	}

	if err := query.Where("is_active = ?", true).Limit(50).Find(&employees).Error; err != nil {
		return nil, fmt.Errorf("failed to get employees: %w", err)
	}

	return employees, nil
}

// MandorHistory is the resolver for the mandorHistory field.
func (r *queryResolver) MandorHistory(ctx context.Context, filter *mandor.MandorHistoryFilter) (*mandor.MandorHistoryResponse, error) {
	userID, ok := ctx.Value("user_id").(string)
	if !ok || userID == "" {
		return nil, fmt.Errorf("user not authenticated")
	}

	return r.PanenResolver.GetMandorHistory(ctx, userID, filter)
}

// MandorHarvestRecord is the resolver for the mandorHarvestRecord field.
func (r *queryResolver) MandorHarvestRecord(ctx context.Context, id string) (*mandor.MandorHarvestRecord, error) {
	// Get the harvest record using existing resolver
	record, err := r.PanenResolver.HarvestRecord(ctx, id)
	if err != nil {
		return nil, err
	}
	if record == nil {
		return nil, nil
	}

	// Convert to MandorHarvestRecord
	return convertToMandorHarvestRecord(record), nil
}

// MandorPendingSyncItems is the resolver for the mandorPendingSyncItems field.
func (r *queryResolver) MandorPendingSyncItems(ctx context.Context, deviceID string) ([]*mandor.MandorPendingSyncItem, error) {
	panic(fmt.Errorf("not implemented: MandorPendingSyncItems - mandorPendingSyncItems"))
}

// MandorServerUpdates is the resolver for the mandorServerUpdates field.
// This returns harvest records that have been updated since the given timestamp.
// Used by mobile app to sync approval status changes from server.
func (r *queryResolver) MandorServerUpdates(ctx context.Context, since time.Time, deviceID string) ([]*mandor.MandorHarvestRecord, error) {
	fmt.Printf("ðŸ“¥ [MandorServerUpdates] Called with since=%v, deviceID=%s\n", since, deviceID)

	// Get the authenticated user's ID from context
	userID, ok := ctx.Value("user_id").(string)
	if !ok || userID == "" {
		fmt.Printf("âŒ [MandorServerUpdates] User not authenticated\n")
		return nil, fmt.Errorf("user not authenticated")
	}
	fmt.Printf("âœ… [MandorServerUpdates] User ID: %s\n", userID)

	// Query harvest records for this mandor that have been updated since the given time
	records, err := r.PanenResolver.GetHarvestRecordsByMandorSince(ctx, userID, since)
	if err != nil {
		fmt.Printf("âŒ [MandorServerUpdates] Database error: %v\n", err)
		return nil, fmt.Errorf("failed to fetch harvest updates: %w", err)
	}
	fmt.Printf("âœ… [MandorServerUpdates] Found %d records\n", len(records))

	// Convert HarvestRecord to MandorHarvestRecord
	result := make([]*mandor.MandorHarvestRecord, len(records))
	for i, record := range records {
		result[i] = convertToMandorHarvestRecord(record)
	}

	fmt.Printf("âœ… [MandorServerUpdates] Returning %d records\n", len(result))
	return result, nil
}

// convertToMandorHarvestRecord converts a HarvestRecord to MandorHarvestRecord
func convertToMandorHarvestRecord(record *mandor.HarvestRecord) *mandor.MandorHarvestRecord {
	if record == nil {
		return nil
	}

	mandorName := ""
	if record.Mandor != nil {
		mandorName = record.Mandor.Name
	}

	blockName := ""
	divisionID := ""
	divisionName := ""
	estateID := ""
	estateName := ""

	if record.Block != nil {
		blockName = record.Block.Name
		if record.Block.Division != nil {
			divisionID = record.Block.Division.ID
			divisionName = record.Block.Division.Name
			if record.Block.Division.Estate != nil {
				estateID = record.Block.Division.Estate.ID
				estateName = record.Block.Division.Estate.Name
			}
		}
	}

	// Get approver name if available
	var approvedByName *string
	if record.ApprovedBy != nil && *record.ApprovedBy != "" {
		// In a real implementation, you might want to lookup the approver's name
		// For now, we'll set it to the ID (the mobile app may need adjustment)
		approvedByName = record.ApprovedBy
	}

	var coordinates *common.Coordinates
	if record.Latitude != nil && record.Longitude != nil {
		coordinates = &common.Coordinates{
			Latitude:  *record.Latitude,
			Longitude: *record.Longitude,
		}
	}

	var photos []*mandor.HarvestPhoto
	if record.PhotoURL != nil && strings.TrimSpace(*record.PhotoURL) != "" {
		serverURL := strings.TrimSpace(*record.PhotoURL)
		photos = []*mandor.HarvestPhoto{
			{
				ID:         fmt.Sprintf("%s-photo", record.ID),
				ServerURL:  &serverURL,
				SyncStatus: common.SyncStatusSynced,
				TakenAt:    record.CreatedAt,
			},
		}
	}

	return &mandor.MandorHarvestRecord{
		ID:                record.ID,
		LocalID:           record.LocalID,
		Tanggal:           record.Tanggal,
		MandorID:          record.MandorID,
		MandorName:        mandorName,
		CompanyID:         record.CompanyID,
		AsistenID:         record.AsistenID,
		BlockID:           record.BlockID,
		BlockName:         blockName,
		DivisionID:        divisionID,
		DivisionName:      divisionName,
		EstateID:          estateID,
		EstateName:        estateName,
		Karyawan:          harvestWorkerLabel(record.Karyawan, record.Nik, record.KaryawanID),
		JumlahJanjang:     record.JumlahJanjang,
		JjgMatang:         record.JjgMatang,
		JjgMentah:         record.JjgMentah,
		JjgLewatMatang:    record.JjgLewatMatang,
		JjgBusukAbnormal:  record.JjgBusukAbnormal,
		JjgTangkaiPanjang: record.JjgTangkaiPanjang,
		TotalBrondolan:    record.TotalBrondolan,
		BeratTbs:          record.BeratTbs,
		Status:            record.Status,
		ApprovedBy:        record.ApprovedBy,
		ApprovedByName:    approvedByName,
		ApprovedAt:        record.ApprovedAt,
		RejectedReason:    record.RejectedReason,
		Notes:             record.Notes,
		Coordinates:       coordinates,
		Photos:            photos,
		CreatedAt:         record.CreatedAt,
		UpdatedAt:         record.UpdatedAt,
		SyncStatus:        common.SyncStatusSynced,
		ServerVersion:     1, // Default version
	}
}

// HarvestRecords is the resolver for the harvestRecords field.
func (r *queryResolver) HarvestRecords(ctx context.Context, dateFrom *time.Time, dateTo *time.Time) ([]*mandor.HarvestRecord, error) {
	userID, role := getCurrentUserScope(ctx)
	if userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	var (
		harvestModels []*panenModels.HarvestRecord
		err           error
	)

	// Create filters
	filters := &panenModels.HarvestFilters{
		DateFrom: dateFrom,
		DateTo:   dateTo,
	}

	switch role {
	case auth.UserRoleMandor:
		harvestModels, err = r.PanenResolver.HarvestRecordsByMandor(ctx, userID, filters)
	case auth.UserRoleManager:
		scopedFilters, hasScope, scopeErr := r.buildScopedHarvestFilters(ctx, userID, role, filters)
		if scopeErr != nil {
			return nil, scopeErr
		}
		if hasScope {
			harvestModels, err = r.PanenResolver.HarvestRecords(ctx, scopedFilters)
			break
		}
		harvestModels, err = r.PanenResolver.HarvestRecordsByManager(ctx, userID, filters)
	case auth.UserRoleAsisten, auth.UserRoleAreaManager, auth.UserRoleCompanyAdmin:
		scopedFilters, hasScope, scopeErr := r.buildScopedHarvestFilters(ctx, userID, role, filters)
		if scopeErr != nil {
			return nil, scopeErr
		}
		if hasScope {
			harvestModels, err = r.PanenResolver.HarvestRecords(ctx, scopedFilters)
			break
		}

		hierarchyFilters, hasHierarchyScope, hierarchyErr := r.buildHierarchyMandorScopedHarvestFilters(ctx, userID, filters)
		if hierarchyErr != nil {
			return nil, hierarchyErr
		}
		if !hasHierarchyScope {
			return []*mandor.HarvestRecord{}, nil
		}
		harvestModels, err = r.PanenResolver.HarvestRecords(ctx, hierarchyFilters)
	default:
		harvestModels, err = r.PanenResolver.HarvestRecords(ctx, filters)
	}
	if err != nil {
		return nil, err
	}

	// Convert slice of internal models to slice of generated types
	result := make([]*mandor.HarvestRecord, len(harvestModels))
	for i, model := range harvestModels {
		result[i] = (*mandor.HarvestRecord)(model)
	}

	return result, nil
}

// HarvestRecord is the resolver for the harvestRecord field.
func (r *queryResolver) HarvestRecord(ctx context.Context, id string) (*mandor.HarvestRecord, error) {
	userID, role := getCurrentUserScope(ctx)
	if userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	var (
		harvestModel *panenModels.HarvestRecord
		err          error
	)
	switch role {
	case auth.UserRoleMandor:
		harvestModel, err = r.PanenResolver.HarvestRecord(ctx, id)
		if err != nil {
			return nil, err
		}
		if harvestModel == nil {
			return nil, nil
		}
		if strings.TrimSpace(harvestModel.MandorID) != userID {
			return nil, fmt.Errorf("harvest record not found")
		}
	case auth.UserRoleManager:
		scopedFilters, hasScope, scopeErr := r.buildScopedHarvestFilters(ctx, userID, role, nil)
		if scopeErr != nil {
			return nil, scopeErr
		}
		if hasScope {
			harvestModel, err = r.PanenResolver.HarvestRecord(ctx, id)
			if err != nil {
				return nil, err
			}
			if harvestModel == nil {
				return nil, nil
			}
			if !isHarvestRecordInScopedAssignments(harvestModel, scopedFilters) {
				return nil, fmt.Errorf("harvest record not found")
			}
			break
		}

		harvestModel, err = r.PanenResolver.HarvestRecordByManager(ctx, id, userID)
		if err != nil {
			var harvestErr *panenModels.HarvestError
			if errors.As(err, &harvestErr) && harvestErr.Code == panenModels.ErrHarvestNotFound {
				return nil, fmt.Errorf("harvest record not found")
			}
			return nil, err
		}
		if harvestModel == nil {
			return nil, nil
		}
	case auth.UserRoleAsisten, auth.UserRoleAreaManager, auth.UserRoleCompanyAdmin:
		scopedFilters, hasScope, scopeErr := r.buildScopedHarvestFilters(ctx, userID, role, nil)
		if scopeErr != nil {
			return nil, scopeErr
		}
		if hasScope {
			harvestModel, err = r.PanenResolver.HarvestRecord(ctx, id)
			if err != nil {
				return nil, err
			}
			if harvestModel == nil {
				return nil, nil
			}
			if !isHarvestRecordInScopedAssignments(harvestModel, scopedFilters) {
				return nil, fmt.Errorf("harvest record not found")
			}
			break
		}

		hierarchyFilters, hasHierarchyScope, hierarchyErr := r.buildHierarchyMandorScopedHarvestFilters(ctx, userID, nil)
		if hierarchyErr != nil {
			return nil, hierarchyErr
		}
		if !hasHierarchyScope {
			return nil, fmt.Errorf("harvest record not found")
		}

		harvestModel, err = r.PanenResolver.HarvestRecord(ctx, id)
		if err != nil {
			return nil, err
		}
		if harvestModel == nil {
			return nil, nil
		}
		if !isHarvestRecordInScopedAssignments(harvestModel, hierarchyFilters) {
			return nil, fmt.Errorf("harvest record not found")
		}
	default:
		harvestModel, err = r.PanenResolver.HarvestRecord(ctx, id)
		if err != nil {
			return nil, err
		}
		if harvestModel == nil {
			return nil, nil
		}
	}

	return (*mandor.HarvestRecord)(harvestModel), nil
}

// HarvestRecordsByStatus is the resolver for the harvestRecordsByStatus field.
func (r *queryResolver) HarvestRecordsByStatus(ctx context.Context, status mandor.HarvestStatus) ([]*mandor.HarvestRecord, error) {
	userID, role := getCurrentUserScope(ctx)
	if userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	var harvestModels []*panenModels.HarvestRecord

	if role == auth.UserRoleMandor {
		records, fetchErr := r.PanenResolver.HarvestRecordsByMandor(ctx, userID, &panenModels.HarvestFilters{
			Status: &status,
		})
		if fetchErr != nil {
			return nil, fetchErr
		}
		harvestModels = records
	} else if role == auth.UserRoleManager {
		filters := &panenModels.HarvestFilters{
			Status: &status,
		}
		scopedFilters, hasScope, scopeErr := r.buildScopedHarvestFilters(ctx, userID, role, filters)
		if scopeErr != nil {
			return nil, scopeErr
		}
		if hasScope {
			records, fetchErr := r.PanenResolver.HarvestRecords(ctx, scopedFilters)
			if fetchErr != nil {
				return nil, fetchErr
			}
			harvestModels = records
		} else {
			records, fetchErr := r.PanenResolver.HarvestRecordsByManagerAndStatus(ctx, userID, status)
			if fetchErr != nil {
				return nil, fetchErr
			}
			harvestModels = records
		}
	} else if role == auth.UserRoleAsisten || role == auth.UserRoleAreaManager || role == auth.UserRoleCompanyAdmin {
		filters := &panenModels.HarvestFilters{
			Status: &status,
		}
		scopedFilters, hasScope, scopeErr := r.buildScopedHarvestFilters(ctx, userID, role, filters)
		if scopeErr != nil {
			return nil, scopeErr
		}
		if hasScope {
			records, fetchErr := r.PanenResolver.HarvestRecords(ctx, scopedFilters)
			if fetchErr != nil {
				return nil, fetchErr
			}
			harvestModels = records
		} else {
			hierarchyFilters, hasHierarchyScope, hierarchyErr := r.buildHierarchyMandorScopedHarvestFilters(ctx, userID, filters)
			if hierarchyErr != nil {
				return nil, hierarchyErr
			}
			if !hasHierarchyScope {
				return []*mandor.HarvestRecord{}, nil
			}

			records, fetchErr := r.PanenResolver.HarvestRecords(ctx, hierarchyFilters)
			if fetchErr != nil {
				return nil, fetchErr
			}
			harvestModels = records
		}
	} else {
		records, fetchErr := r.PanenResolver.HarvestRecordsByStatus(ctx, status)
		if fetchErr != nil {
			return nil, fetchErr
		}
		harvestModels = records
	}

	// Convert slice of internal models to slice of generated types
	result := make([]*mandor.HarvestRecord, len(harvestModels))
	for i, model := range harvestModels {
		result[i] = (*mandor.HarvestRecord)(model)
	}

	return result, nil
}

// MandorHarvestStatusUpdate is the resolver for the mandorHarvestStatusUpdate field.
func (r *subscriptionResolver) MandorHarvestStatusUpdate(ctx context.Context) (<-chan *mandor.MandorHarvestRecord, error) {
	panic(fmt.Errorf("not implemented: MandorHarvestStatusUpdate - mandorHarvestStatusUpdate"))
}

// MandorSyncUpdate is the resolver for the mandorSyncUpdate field.
func (r *subscriptionResolver) MandorSyncUpdate(ctx context.Context, deviceID string) (<-chan *mandor.MandorSyncStatus, error) {
	panic(fmt.Errorf("not implemented: MandorSyncUpdate - mandorSyncUpdate"))
}

// HarvestRecordCreated is the resolver for the harvestRecordCreated field.
func (r *subscriptionResolver) HarvestRecordCreated(ctx context.Context) (<-chan *mandor.HarvestRecord, error) {
	return subscribeHarvestRecordCreated(ctx)
}

// HarvestRecordApproved is the resolver for the harvestRecordApproved field.
func (r *subscriptionResolver) HarvestRecordApproved(ctx context.Context) (<-chan *mandor.HarvestRecord, error) {
	return subscribeHarvestRecordApproved(ctx)
}

// HarvestRecordRejected is the resolver for the harvestRecordRejected field.
func (r *subscriptionResolver) HarvestRecordRejected(ctx context.Context) (<-chan *mandor.HarvestRecord, error) {
	return subscribeHarvestRecordRejected(ctx)
}
